-- Bundled by luabundle {"rootModuleName":"Yellow Machine.46ccee.lua","version":"1.6.0"}
local __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)
	local loadingPlaceholder = {[{}] = true}

	local register
	local modules = {}

	local require
	local loaded = {}

	register = function(name, body)
		if not modules[name] then
			modules[name] = body
		end
	end

	require = function(name)
		local loadedModule = loaded[name]

		if loadedModule then
			if loadedModule == loadingPlaceholder then
				return nil
			end
		else
			if not modules[name] then
				if not superRequire then
					local identifier = type(name) == 'string' and '\"' .. name .. '\"' or tostring(name)
					error('Tried to require ' .. identifier .. ', but no such module has been registered')
				else
					return superRequire(name)
				end
			end

			loaded[name] = loadingPlaceholder
			loadedModule = modules[name](require, loaded, register, modules)
			loaded[name] = loadedModule
		end

		return loadedModule
	end

	return require, loaded, register, modules
end)(nil)
__bundle_register("Yellow Machine.46ccee.lua", function(require, _LOADED, __bundle_register, __bundle_modules)
require("vscode/console")

local DEBUG = false

local loadedData, loadedDataOrder, originalLoadedOrder, edition, uiHeight, uiWidth, useDecorativeNames, armyDisplay, armyText
local url = DEBUG and "http://localhost:3000/get_army_by_id?id=" or "https://yellowscribe.link/get_army_by_id?id="

local uiTemplates = {
    UNIT_CONTAINER = [[ <VerticalLayout class="transparent" childForceExpandHeight="false">
                            <Text class="unitName">${unitName}</Text>
                            <VerticalLayout class="unitContainer" childForceExpandHeight="false" preferredHeight="${height}" spacing="20">
                                ${unitData}
                            </VerticalLayout>
                        </VerticalLayout> ]],
    MODEL_CONTAINER = [[<VerticalLayout preferredWidth="500" childForceExpandHeight="false" class="modelContainer" id="${unitID}|${modelID}" preferredHeight="${height}">
                            <Text class="modelDataName">${numberString}${modelName}</Text>
                            ${weapons}
                            ${abilities}
                        </VerticalLayout> ]],
    MODEL_DATA = [[ <VerticalLayout childForceExpandHeight="false" childForceExpandWidth="false">
                        <Text height="15"><!-- spacer --></Text>
                        <Text class="modelDataTitle">${dataType}</Text>
                        <Text class="modelData" preferredHeight="${height}">${data}</Text>
                    </VerticalLayout> ]],

    MODEL_GROUPING_CONTAINER = [[ <HorizontalLayout class="groupingContainer">${modelGroups}</HorizontalLayout> ]]
}

--[[ UNIT SCRIPTING DATA ]]--
--[[ everything in this section is meant to be a string because this is what we
are inputting into created models ]]--

local UNIT_SPECIFIC_DATA_TEMPLATE = [[ --[[ UNIT-SPECIFIC DATA ${endBracket}--
local unitData = {
    edition = "${edition}",
    unitName = "${unitName}",
    unitDecorativeName = "${unitDecorativeName}",
    factionKeywords = "${factionKeywords}",
    keywords = "${keywords}",
    abilities = {
        ${abilities}
    },
    models = {
        ${models}
    }${changingCharacteristics}${woundTrack},
    weapons = {
        ${weapons}
    }${psychic},
    uuid = "${uuid}"${singleModel},
    uiHeight = ${height},
    uiWidth = ${width}
} ]]
local CHANGING_CHARACTERISTICS_TEMPLATE = [[,
    changingCharacteristics = {
        ${changingChars}
    },
]]
local WEAPON_TEMPLATE_9E = [[[c6c930]${name}[-]
${rangeAndType} S:${s} AP:${ap} D:${d} ${ability} ]]
local RANGED_WEAPON_TEMPLATE_10E = [[[c6c930]${name}[-]
${range} A:${a} BS:${bs} S:${s} AP:${ap} D:${d} [7bc596]${ability}[-] ]]
local MELEE_WEAPON_TEMPLATE_10E = [[[c6c930]${name}[-]
A:${a} WS:${ws} S:${s} AP:${ap} D:${d} [7bc596]${ability}[-] ]]
local DEFAULT_BRACKET_VALUE_TEMPLATE = "[98ffa7]${val}[-]"
local ABILITITY_STRING_TEMPLATE = '{ name = [[${name}]], desc = [=[${desc}]=] }'
local WEAPON_ENTRY_TEMPLATE_9E = '{ name="${name}", range=[[${range}]], type="${type}", s="${s}", ap="${ap}", d="${d}", abilities=[[${abilities}]] }'
local WEAPON_ENTRY_TEMPLATE_10E = '{ name="${name}", range=[[${range}]], a="${a}", bsws="${bsws}", s="${s}", ap="${ap}", d="${d}", abilities=[[${abilities}]], shortabilities=[[${shortabilities}]] }'
local CHANGING_CHARACTERISTICS_ENTRY_TEMPLATE = '["${name}"] = { "${characteristics}" }'
local WOUND_TRACK_ENTRY_TEMPLATE = [[       ["${name}"] = {
            ${tracks}
        }]]
local PSYKER_PROFILE_TEMPLATE = [[      ["${name}"] = ${profiles}]]
local PSYCHIC_POWER_TEMPLATE = [[${name} (${warpCharge}, ${range})]]
local PSYCHIC_POWER_ENTRY_TEMPLATE = '{ name="${name}", warpCharge="${warpCharge}", range=[[${range}]], details=[[${details}]] }'





local YELLOW_STORAGE_GUID = "43ecc1"
local ARMY_BOARD_GUID = "2955a6"
local DELETION_ZONE_GUID = "f33dff"
local AGENDA_MANAGER_GUID = "45cd3f"
local IS_IN_HOME_MOD
local yellowStorage,YELLOW_STORAGE_XML,YELLOW_STORAGE_SCRIPT,army,armyBoard,uiHeight,uiWidth,edition
local SLOT_POINTS = {slot={},boundingBox={},placed={},models={}}
local SLOTS_TO_DISPLAY = {
    "slot",
    "boundingBox",
    "placed",
    "models"
}
local DEFAULT_MODEL_SPACING = 0.15
local DEFAULT_FOOTPRINT_PADDING = 0.5
local BOUNDING_BOX_RATIO = 2
local MODEL_PLACEMENT_Y = 5.4
local ARMY_PLACEMENT_STARTING_X = -5
local ARMY_PLACEMENT_STARTING_Z = -7
local WEAPON_TYPE_VALUES = {
    ["rapid fire"] = 0,
    ["assault"] = 0,
    ["heavy"] = 0,
    ["macro"] = 0,
    ["pistol"] = 1,
    ["grenade"] = 2,
    ["melee"] = 3
}
local CREATE_ARMY_BUTTON = {
    label="CREATE ARMY", click_function="createArmy", function_owner=self,
    position={0.5,1.5,0}, rotation={180,0,180}, height=550, width=2750, font_size=220, font_style = "Bold",
    font_color={1,1,1}, color={0,150/255,0}
}
local ON_BUTTON = {
    label="LOAD ROSTER", click_function="turnOnYellowMachine", function_owner=self,
    position={0,0.52,0}, rotation={180,0,180}, height=550, width=2750, font_size=220, font_style = "Bold",
    font_color={1,1,1}, color={0,150/255,0}
}
local modelAssociations,activeButtons = {},{}
local numAssociatedObjects,firstModelAssociation = 0,true
local ERROR_RED = { 1, 0.25, 0.25 }






-- Hopefully-temporary code to deal with the outbreak of a TTS virus
-- This code is copied from https://steamcommunity.com/sharedfiles/filedetails/?id=2967684892
-- published by Larrie Corvell, thanks Larrie. It has been modified.
-- It's licensed under Creative Commons Attribution-ShareAlike 4.0 International License
-- (https://creativecommons.org/licenses/by-sa/4.0/).

local sillySpaces = string.rep("  ", 90)
local naiveRemovalPattern = string.format("(%s.+)$", sillySpaces)
function detectSillySpaces(obj)
    local script = obj.getLuaScript()
    if string.find(script, sillySpaces) then
        return true, script
    end
end

function clean(obj, debugNote)
    Wait.stopAll()
    local hasSillySpaces, script = detectSillySpaces(obj)
    if hasSillySpaces then
        local cleanedScript = string.gsub(script, naiveRemovalPattern, "")
        obj.setLuaScript(cleanedScript)
        print("One or more of the models you just spawned in contained malicious code. Yellowscribe has deleted it and the model is now safe to use, but you should contact the source of the model to get them to fix it.")
    end
end

function onObjectSpawn(obj)
    clean(obj, "onObjectSpawn")
end

function onObjectLeaveContainer(container, obj)
    clean(obj, "onObjectLeaveContainer")
end

-- End virus handling code




function moveToLoadingScreen()
    if armyText ~= nil and armyText ~= "" then
        if #armyText == 8 then
            loadedData = nil
            UI.hide("welcomeWindow")
            UI.show("loading")
            Wait.time(|| sendRequest(armyText), 0.2)
        else
            broadcastToAll("It looks like your Yellowscribe code is malformed, please make sure to enter it correctly!", ERROR_RED)
            return
        end
    else
        broadcastToAll("Please paste your code into the box before clicking submit!", ERROR_RED)
        return
    end

    Wait.time(function () -- delay so that animations dont blend
        Wait.condition(function ()
            if loadedData.err == nil then

                loadEditedArmy(loadedData)
            else
                UI.hide("loading")
                -- wait because sometimes the response comes back before the loading screen even shows up
                Wait.time(function ()
                    broadcastToAll(loadedData.err, ERROR_RED)
                    UI.show("welcomeWindow")
                end, 0.2)
            end
        end,
        || loadedData ~= nil,
        20,
        function ()
            UI.hide("loading")
            broadcastToAll("Something has gone horribly wrong! Please try again.", ERROR_RED)
            UI.show("welcomeWindow")
        end)
    end, 0.15)
end

function sendRequest(data)
    -- Perform the request
    log(url..data)
    WebRequest.get(url..data, handleResponse)
end

function handleResponse(response)
    -- Check if the request failed to complete e.g. if your Internet connection dropped out.
    if response.is_error then
        broadcastToAll("Something went wrong at the server!", ERROR_RED)
        log(response.text)
        return
    end

    local data = JSON.decode(response.text)

    if data.err ~= nil then
        loadedData = data
    else
        loadedData = {}
        loadedData.uiHeight = data.uiHeight
        loadedData.uiWidth = data.uiWidth
        YELLOW_STORAGE_SCRIPT = data.baseScript
        loadedData.armyData = data.armyData
        loadedData.height = data.height
        loadedData.xml = data.xml
        loadedData.order = data.order
        loadedData.useDecorativeNames = data.decorativeNames == "true"
        loadedData.edition = data.edition
    end
end

function updateArmyInputText(player, text)
    armyText = text
end

function acceptEditedArmy()
    UI.hide("mainPanel")
    loadEditedArmy({ -- args sent as table because this used to be Global and I'm too lazy to rewrite it
        data = loadedData,
        order = originalLoadedOrder,
        uiHeight = uiHeight,
        uiWidth = uiWidth,
        useDecorativeNames = useDecorativeNames
    })
end

function turnOnYellowMachine()
    showWindow("welcomeWindow")
end








--[[ EVENT HANDLERS ]]--


function onLoad()
    IS_IN_HOME_MOD = Global.getVar("isYMBS2TTS") ~= nil

    yellowStorage = getObjectFromGUID(YELLOW_STORAGE_GUID)
    YELLOW_STORAGE_XML = yellowStorage.getData().XmlUI
    YELLOW_STORAGE_SCRIPT = yellowStorage.getLuaScript()

    if not IS_IN_HOME_MOD then
        getObjectFromGUID(AGENDA_MANAGER_GUID).destroy()
        getObjectFromGUID(DELETION_ZONE_GUID).destroy()
        yellowStorage.destroy()

        self.setPosition({x=0, y=4, z=0})
        self.createButton(ON_BUTTON)
        self.setLock(false)

        CREATE_ARMY_BUTTON.position = {0,0.6,0}
    else
        showWindow("welcomeWindow")
    end
end

function onScriptingButtonDown(index, player_color)
    --slotPoints = { {5,1,5}, {-5,1,-5} }
    if DEBUG then
        Global.setVectorLines(SLOT_POINTS[SLOTS_TO_DISPLAY[index]])
    end
end

function onPlayerAction(player, action, targets)
    if action == Player.Action.PickUp and #activeButtons > 0 then
        makeSureObjectsAreAttached(targets)

        local intendedTargets

        if #player.getSelectedObjects() == 0 then
            intendedTargets = { player.getHoverObject() }
        else
            intendedTargets = player.getSelectedObjects()

            if not includes(intendedTargets, player.getHoverObject()) then
                table.insert(intendedTargets, player.getHoverObject())
            end
        end

        local targetsData = map(intendedTargets, function (target)
            local data = target.getData()

            data.States = nil

            return data
        end)

        for _,activeButton in pairs(activeButtons) do
            local buttonModel = army[activeButton.unit].models.models[activeButton.model]

            buttonModel.associatedModels = targetsData

            -- its ok if we overwrite this every time, we only ever need one and they shooould be all the same
            buttonModel.associatedModelBounds = intendedTargets[1].getBoundsNormalized()

            self.UI.setAttributes(activeButton.buttonID, {
                color = "#33ff33"
            })
        end

        for _,target in ipairs(intendedTargets) do
            target.highlightOn({ r=51/255, g=1, b=51/255 }, 2)
        end

        activeButtons = {}
    end
end





--[[ MODEL SELECTION ]]--


function selectModelGroup(player,_, unitAndModelID)
    local idValues = split(unitAndModelID, "|")
    local unitID,modelID = idValues[1], idValues[2]
    local sameButtonIndex = find(map(activeButtons, |button| button.buttonID), unitAndModelID)

    if sameButtonIndex > 0 then
        for _,modelData in ipairs(army[unitID].models.models[modelID].associatedModels) do
            getObjectFromGUID(modelData.GUID).highlightOff()
        end
        army[unitID].models.models[modelID].associatedModels = nil
        table.remove(activeButtons, sameButtonIndex)
        self.UI.setAttribute(unitAndModelID, "color", "White")
    else
        table.insert(activeButtons, { unit = unitID, model = modelID, buttonID = unitAndModelID })
        self.UI.setAttribute(unitAndModelID, "color", "#ff00ca")

        if #activeButtons == 1 then -- if it's the first button selected
            broadcastToAll("Pick up a model or models to represent your selection!", {r=1, g=0, b=202/255})
        end
    end
end

function showAssociatedModel(_,_, button)
    highlightAssociatedModel(button, true)
end

function hideAssociatedModel(_,_, button)
    highlightAssociatedModel(button, false)
end

function highlightAssociatedModel(unitAndModelID, on)
    local idValues = split(unitAndModelID, "|")
    local buttonModel = army[idValues[1]].models.models[idValues[2]]

    if buttonModel.associatedModels ~= nil and #buttonModel.associatedModels > 0 then
        for _,associatedModel in ipairs(buttonModel.associatedModels) do
            local object = getObjectFromGUID(associatedModel.GUID)

            if object ~= nil then
                if on then
                    object.highlightOn({ r=51/255, g=1, b=51/255 })
                else
                    object.highlightOff()
                end
            end
        end
    end
end

function makeSureObjectsAreAttached(objects)
    for _,attachmentSet in ipairs(getObjectsToAttach(filter(objects, |object| #object.getJoints() > 0))) do
        for _,jointedObj in pairs(attachmentSet.toAttach) do
            if attachmentSet.lowestObj ~= jointedObj then
                attachmentSet.lowestObj.addAttachment(jointedObj)
            end
        end
    end
end

function getObjectsToAttach(objects)
    local toAttach = {}

    for _,object in ipairs(objects) do
        local attachmentSet = getObjectsToAttachRecursive(object, {}, {
            lowestY = object.getPosition().y,
            lowestObj = object,
            toAttach = { [object.getGUID()]=object }
        })

        for guid,_ in pairs(attachmentSet.toAttach) do
            for _,set in ipairs(toAttach) do
                if set.toAttach[guid] ~= nil then
                    mergeAttachmentSets(attachmentSet, set)
                    goto afterInsert
                end
            end
        end

        table.insert(toAttach, attachmentSet)
        ::afterInsert::
    end

    return toAttach
end

function getObjectsToAttachRecursive(object, found, toAttachTable)
    for _,joint in ipairs(object.getJoints()) do
        if found[joint.joint_object_guid] == nil then
            local jointedObj = getObjectFromGUID(joint.joint_object_guid)
            local jointedObjY = jointedObj.getPosition().y

            found[joint.joint_object_guid] = true
            toAttachTable.toAttach[joint.joint_object_guid] = jointedObj

            if jointedObjY < toAttachTable.lowestY then
                toAttachTable.lowestY = jointedObjY
                toAttachTable.lowestObj = jointedObj
            end

            getObjectsToAttachRecursive(jointedObj, found, toAttachTable)
        end
    end

    return toAttachTable
end

function mergeAttachmentSets(setToMerge, mergeIntoSet)
    for guid,obj in pairs(setToMerge.toAttach) do
        if mergeIntoSet.toAttach[guid] == nil then
            mergeIntoSet.toAttach[guid] = obj
        end
    end

    if setToMerge.lowestY < mergeIntoSet.lowestY then
        mergeIntoSet.lowestY = setToMerge.lowestY
        mergeIntoSet.lowestObj = setToMerge.lowestObj
    end
end








--[[ ARMY CREATION ]]--

-- formats and creates the army based on selected models
function createArmy()
    -- we only want to create models for ones that have a model selected
    local unitsToCreate = filter(army, function (unit)
        unit.models.models = filter(unit.models.models, function (model)
            if model.associatedModels == nil or #model.associatedModels == 0 then
                -- make sure we are spawning thr right number of models if only part of a unit is beign spawned
                unit.models.totalNumberOfModels = unit.models.totalNumberOfModels - model.number
            end

            return model.associatedModels ~= nil and #model.associatedModels > 0
        end)

        return len(unit.models.models) > 0
    end)

    if len(unitsToCreate) == 0 then
        broadcastToAll("You haven't selected any models!", ERROR_RED)
        return
    end

    -- delete anything that might get in the way in the future
    deleteAllObjectsInCreationZone()

    -- this feels so inefficient to go through the array so many times,
    -- but at this point, the array really shouldn't be that long,
    -- so I dont have to worry too much about big-O
    unitsToCreate = table.sort(map(unitsToCreate, function (unit)
        unit.models.models = table.sort(unit.models.models, |modelA, modelB| modelA.number < modelB.number)

        --[[ for _,model in ipairs(unit.models.models) do
            model.associatedModel = getObjectFromGUID(model.associatedModel)
        end --]]

        unit.footprint = determineFootprint(unit)

        return unit
    end), function (unitA, unitB)
        if unitA.footprint.width == unitB.footprint.width then
            return unitB.footprint.height < unitA.footprint.height
        end

        return unitA.footprint.width > unitB.footprint.width
    end)

    local selfPosition = self.getPosition()

    -- at this point, we should have a list of units sorted by width then height of their footprints
    placeArmy(unitsToCreate, ARMY_PLACEMENT_STARTING_X + selfPosition.x, ARMY_PLACEMENT_STARTING_Z + selfPosition.z, selfPosition.y)
end


function placeArmy(unitMap, startingX, startingZ, startingY)
    local emptySlots = {} -- {{x,z,h,w},...}
    local boundingBox = { h=0, w=0 }

    for _,unit in pairs(unitMap) do
        local placedInEmptySlot = false

        -- try to place at an origin
        for idx,slot in ipairs(emptySlots) do
            if unit.footprint.height <= slot.h and unit.footprint.width <= slot.w then
                placeUnit(unit, startingX-slot.x, startingZ+slot.z, startingY)

                if DEBUG then
                    table.insert(SLOT_POINTS.placed, { points= {
                        {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z},
                        {startingX-slot.x-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z},
                        {startingX-slot.x-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z+unit.footprint.height},
                        {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z+unit.footprint.height},
                        {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z}
                    },
                    color = {0,0,0}})
                end

                table.remove(emptySlots, idx)

                -- slot to the side should be filled first if possible
                -- so insert the top one first
                if (slot.h - unit.footprint.height) >= 1 then
                    if DEBUG then
                        table.insert(SLOT_POINTS.slot,{points= {
                            {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z+unit.footprint.height},
                            {startingX-slot.x-slot.w,MODEL_PLACEMENT_Y+1,startingZ+slot.z+unit.footprint.height},
                            {startingX-slot.x-slot.w,MODEL_PLACEMENT_Y+1,startingZ+slot.z+slot.h},
                            {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z+slot.h},
                            {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z+unit.footprint.height}
                        },
                        color = {0,1,0}})
                    end

                    table.insert(emptySlots, {
                        x = slot.x,
                        z = slot.z + unit.footprint.height,
                        h = slot.h - unit.footprint.height,
                        w = slot.w
                    })
                end

                if (slot.w - unit.footprint.width) >= 1 then
                    if DEBUG then
                        table.insert(SLOT_POINTS.slot,{ points = {
                            {startingX-slot.x-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z},
                            {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+slot.z},
                            {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+slot.z+unit.footprint.height},
                            {startingX-slot.x-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z+unit.footprint.height},
                            {startingX-slot.x-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z}
                        },
                        color = {0,0,1}})
                    end

                    table.insert(emptySlots, {
                        x = slot.x + unit.footprint.width,
                        z = slot.z,
                        w = slot.w - unit.footprint.width,
                        h = unit.footprint.height
                    })
                end
                -- >= 1 because we dont want to make additional tiny slots that will never be filled

                placedInEmptySlot = true
                break;
            end
        end

        if placedInEmptySlot then -- do nothing

        -- if expanding upward makes sense
        elseif (boundingBox.h + unit.footprint.height) < (boundingBox.w * BOUNDING_BOX_RATIO) then
            placeUnit(unit, startingX, startingZ + boundingBox.h, startingY)

            if DEBUG then
                table.insert(SLOT_POINTS.placed, { points= {
                    {startingX,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},
                    {startingX-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},
                    {startingX-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h+unit.footprint.height},
                    {startingX,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h+unit.footprint.height},
                    {startingX,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h}
                },
                color = {0,0,0}})
            end

            if (boundingBox.w - unit.footprint.width >= 1) then
                if DEBUG then
                    table.insert(SLOT_POINTS.slot, { points= {
                        {startingX-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},
                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},
                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h+unit.footprint.height},
                        {startingX-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h+unit.footprint.height},
                        {startingX-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h}
                    },
                    color = {1,0,1}})
                end

                table.insert(emptySlots, {
                    x = unit.footprint.width,
                    z = boundingBox.h,
                    h = unit.footprint.height,
                    w = boundingBox.w - unit.footprint.width
                })
            end

            boundingBox.h = boundingBox.h + unit.footprint.height

        -- else place at far left
        else
            placeUnit(unit, startingX - boundingBox.w, startingZ, startingY)

            if DEBUG then
                table.insert(SLOT_POINTS.placed, { points= {
                    {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ},
                    {startingX-boundingBox.w-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ},
                    {startingX-boundingBox.w-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+unit.footprint.height},
                    {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+unit.footprint.height},
                    {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ}
                },
                color = {0,0,0}})
            end

            if boundingBox.h - unit.footprint.height >= 1 then
                if DEBUG then
                    table.insert(SLOT_POINTS.slot, { points= {
                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+unit.footprint.height},
                        {startingX-boundingBox.w-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+unit.footprint.height},
                        {startingX-boundingBox.w-unit.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},
                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},
                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+unit.footprint.height}
                    },
                    color = {0,0,0}})
                end

                table.insert(emptySlots, {
                    x = boundingBox.w,
                    z = unit.footprint.height,
                    h = boundingBox.h - unit.footprint.height,
                    w = unit.footprint.width
                })
            end

            boundingBox.w = boundingBox.w + unit.footprint.width

            if boundingBox.h == 0 then boundingBox.h = unit.footprint.height end -- handle first unit
        end
    end

    if DEBUG then
        SLOT_POINTS.boundingBox = {{
            points= {
                {startingX, MODEL_PLACEMENT_Y+1, startingZ},
                {startingX-boundingBox.w, MODEL_PLACEMENT_Y+1, startingZ},
                {startingX-boundingBox.w, MODEL_PLACEMENT_Y+1, startingZ+boundingBox.h},
                {startingX, MODEL_PLACEMENT_Y+1, startingZ+boundingBox.h},
                {startingX, MODEL_PLACEMENT_Y+1, startingZ},
            },
            color = {0,0,0}
        }}
    end

    local boardPosition = { x=startingX-(boundingBox.w*0.5), y=5+startingY, z=startingZ+(boundingBox.h * 0.5) }
    local boardScale = { x=(0.5*boundingBox.w), y=1, z=(0.5*boundingBox.h)}

    if armyBoard == nil then
        armyBoard = spawnObject({
            type = "Custom_Tile",
            sound = false,
            position = boardPosition,
            scale = boardScale
        })
        armyBoard.setCustomObject({
            image = "http://cloud-3.steamusercontent.com/ugc/1698405413696745750/BC055E0445A3CEC1A0A0754CF4F1646977612B09/",
            thickness = 0.37
        })
        armyBoard.setLock(true)
    else
        armyBoard.setScale(boardScale)
        armyBoard.setPosition(boardPosition)
    end
end


function placeUnit(unit, startX, startZ, startY)
    -- cheap way of determining a "sergeant" model:
    -- sort by number, pick the first, hope for the best
    local isFirstModel = true
    local xOffset = startX - DEFAULT_FOOTPRINT_PADDING -- left is negative
    local zOffset = startZ + DEFAULT_FOOTPRINT_PADDING -- up is positive
    local modelSize
    local currentRowHeight,currentModelsInRow = 0,0
    local leaderData = formatLeaderScript(unit)

    for modelID,model in pairs(unit.models.models) do
        --local currentModelObj = getObjectFromGUID(model.associatedModel)
        -- I dont remember why I'm passing the data as an object instead of just as arguments
        local modelProfile = getProfileForModel(model, unit)
        local modelDescription = buildModelDescription(model, unit, modelProfile)
        local modelNickname = (modelProfile ~= nil and ("[00ff16]"..modelProfile.w.."/"..modelProfile.w.."[-] ") or "")
                                ..getModelDisplayName(model, unit)
        local modelTags = getModelTags(model, unit)

        local modelData = formatModelData(model.associatedModels,
                                            modelDescription,
                                            modelNickname,
                                            modelTags)

        modelSize = model.associatedModelBounds.size
        --log(model)

        if currentRowHeight < modelSize.z then currentRowHeight = modelSize.z end

        for i=1,model.number do
            createModelFromData(chooseRandomModel(modelData),
                                --unit.decorativeName and unit.decorativeName or unit.name,
                                xOffset-(modelSize.x*0.5),
                                zOffset+(modelSize.z*0.5),
                                startY,
                                leaderData)
            table.insert(SLOT_POINTS.models,{ points = {
                {xOffset,MODEL_PLACEMENT_Y+1,zOffset},
                {xOffset-modelSize.x,MODEL_PLACEMENT_Y+1,zOffset},
                {xOffset-modelSize.x,MODEL_PLACEMENT_Y+1,zOffset+modelSize.z},
                {xOffset,MODEL_PLACEMENT_Y+1,zOffset+modelSize.z},
                {xOffset,MODEL_PLACEMENT_Y+1,zOffset}
            },
            color = {0,0,1}})
            leaderData = nil
            currentModelsInRow = currentModelsInRow + 1


            if currentModelsInRow == unit.modelsPerRow then
                currentModelsInRow = 0
                xOffset = startX - DEFAULT_FOOTPRINT_PADDING
                zOffset = zOffset + currentRowHeight + DEFAULT_MODEL_SPACING
            else
                xOffset = xOffset - (modelSize.x + DEFAULT_MODEL_SPACING)
            end
        end
    end
end

-- determines how much space a unit should take up once it is created
function determineFootprint(unit)
    -- determine models per row
    local modelsPerRow = unit.models.totalNumberOfModels
    local currentModelsInRow,currentWidth,footprintWidth,footprintHeight,modelsLeft = 0,0,0,0,0
    local currentRow = 1
    local currentHeights = {}
    local currentModelBounds

    if modelsPerRow > 5 then
        if modelsPerRow < 20 and modelsPerRow % 3 == 0 then
            if modelsPerRow < 12 then modelsPerRow = 3
            else modelsPerRow = modelsPerRow / 3 end
        elseif modelsPerRow < 20 and modelsPerRow % 5 == 0 then
            modelsPerRow = 5
        elseif modelsPerRow > 10 then
            modelsPerRow = 10
        end
    end

    unit.modelsPerRow = modelsPerRow

    -- I realize that this is doing almost exactly what we will do later when actually creating the models
    -- unfortunately, this is the only way that I can think of to guarantee the footprint of a unit
    -- with models of different sizes
    for _,model in pairs(unit.models.models) do
        currentModelBounds = model.associatedModelBounds.size

        if currentHeights[currentRow] == nil or currentModelBounds.z > currentHeights[currentRow] then
            currentHeights[currentRow] = currentModelBounds.z
        end

        if (currentModelsInRow + model.number) >= modelsPerRow then
            currentWidth = currentWidth + ((modelsPerRow - currentModelsInRow) * (currentModelBounds.x + DEFAULT_MODEL_SPACING))

            if currentWidth > footprintWidth then footprintWidth = currentWidth end

            modelsLeft = model.number - (modelsPerRow - currentModelsInRow)
            currentRow = currentRow + 1

            while modelsLeft >= modelsPerRow do
                table.insert(currentHeights, currentModelBounds.z + DEFAULT_MODEL_SPACING)
                currentRow = currentRow + 1
                modelsLeft = modelsLeft - modelsPerRow
                currentWidth = (currentModelBounds.x + DEFAULT_MODEL_SPACING) * modelsPerRow
            end

            if modelsLeft > 0 then
                table.insert(currentHeights, currentModelBounds.z + DEFAULT_MODEL_SPACING)
                currentModelsInRow = modelsLeft
            end

            if currentWidth > footprintWidth then footprintWidth = currentWidth end

            currentWidth = currentModelsInRow * (currentModelBounds.x + DEFAULT_MODEL_SPACING)
        else
            currentWidth = currentWidth + (model.number * (currentModelBounds.x + DEFAULT_MODEL_SPACING))
            currentModelsInRow = currentModelsInRow + model.number
        end
    end

    --if footprintHeight == 0 then footprintHeight = currentHeight end -- in case it hasnt been set yet (usually only because a row hasnt been filled)
    for _,height in ipairs(currentHeights) do
        footprintHeight = footprintHeight + height
    end

    return { width = footprintWidth+(2*DEFAULT_FOOTPRINT_PADDING), height = footprintHeight+(2*DEFAULT_FOOTPRINT_PADDING) }
end

-- formats both the leader and follower model data from a given model
function formatModelData(associatedModels, description, nickname, tags)
    for _,modelData in ipairs(associatedModels) do
        modelData.Description = description
        modelData.Nickname = nickname
        modelData.Tags = tags
        -- make sure base data doesnt include any xml or luascript
        modelData.XmlUI = ""
        modelData.LuaScript = ""
        modelData.LuaScriptState = nil
    end

    return associatedModels
end


function formatLeaderScript(unit)
    return interpolate(UNIT_SPECIFIC_DATA_TEMPLATE, {
        edition = edition,
        unitName = unit.name,
        unitDecorativeName = (unit.decorativeName ~= nil and unit.decorativeName ~= "") and unit.decorativeName:gsub('"', '\\"') or unit.name,

        factionKeywords = table.concat(unit.factionKeywords, ", "), -- dont break xml   --map(unit.factionKeywords, |keyword| (keyword:gsub(">", "＞"):gsub("<", "＜")))

        keywords = table.concat(unit.keywords, ", "), -- dont break xml   --map(unit.keywords, |keyword| (keyword:gsub(">", "＞"):gsub("<", "＜")))

        abilities = getFormattedAbilities(unit.abilities, unit.rules),

        models = table.concat(map(unit.modelProfiles, function (profile)
            -- if the unit has brackets, treat each one as a separate model
            if unit.woundTrack ~= nil and unit.woundTrack[profile.name] then
                local toReturn = {}
                local originalName = profile.name
                local changing

                for key,bracket in pairs(unit.woundTrack[profile.name]) do
                    profile.name = originalName.." ("..key..")"
                    changing = tableToFlatString(profile)

                    -- this seems like an inefficient way of doing it, but was the easiest to come up with
                    for _,val in ipairs(bracket) do
                        changing = changing:gsub("%*", val:gsub('"', '\\"'), 1)
                    end

                    table.insert(toReturn, changing)
                end

                return table.concat(toReturn, ",\n\t\t")
            end

            -- otherwise, just add the model
            return tableToFlatString(profile)
        end), ",\n\t\t"),

        weapons = table.concat(map(unit.weapons, |weapon| interpolate(edition == "10e" and WEAPON_ENTRY_TEMPLATE_10E or WEAPON_ENTRY_TEMPLATE_9E, weapon)), ",\n\t\t"),

        endBracket = "]]",
        uuid = unit.uuid,
        height = uiHeight,
        width = uiWidth,

        changingCharacteristics = unit.woundTrack == nil and "" or interpolate(CHANGING_CHARACTERISTICS_TEMPLATE, {
            changingChars = formatChangingCharacteristics(unit)
        }),

        woundTrack = unit.woundTrack == nil and "" or "\twoundTrack = "..tableToString(map(unit.woundTrack, function (tracks, name)
            return interpolate(WOUND_TRACK_ENTRY_TEMPLATE, {
                tracks = table.concat(map(tracks, function (track, key)
                    local temp = '["'..key..'"] = { "'

                    temp = temp..table.concat(map(track, |val| (val:gsub('"', '\\"'))), '", "')

                    return temp..'" }'
                end), ",\n\t\t\t", start_index, end_index ),
                name = name
            })

        end), ",\n", true, "\t"),

        singleModel = (not unit.isSingleModel) and "" or ",\n\tisSingleModel = true",

        psychic = unit.psykerProfiles == nil and "" or ",\n\tpsykerProfiles = "..
            tableToString(map(unit.psykerProfiles, |profile| tableToFlatString(profile)), ",\n\t\t", true, "\t", "\t\t")..
            ",\n\tpowersKnown = "..
            tableToString(map(unit.powersKnown, |power| interpolate(PSYCHIC_POWER_ENTRY_TEMPLATE, power)), ",\n\t\t", true, "\t", "\t\t")
    })..YELLOW_STORAGE_SCRIPT
end

function formatChangingCharacteristics(unit)
    local changing = {}

    for _,profile in pairs(unit.modelProfiles) do
        for char,val in pairs(profile) do -- profile
            if val == "*" then
                if changing[profile.name] == nil then changing[profile.name] = {} end

                table.insert(changing[profile.name], char)
            end
        end
    end

    --[[ for name,_ in pairs(unit.woundTrack) do

        changing[name] = {}

        for char,val in pairs(unit.modelProfiles[name]) do -- profile
            if val == "*" then table.insert(changing[name], char) end
        end
    end --]]

    local toReturn = {}

    for name,arr in pairs(changing) do
        table.insert(toReturn, interpolate(CHANGING_CHARACTERISTICS_ENTRY_TEMPLATE, {
            characteristics = table.concat(arr, '", "'),
            name = name
        }))
    end

    return table.concat(toReturn, ",\n\t\t")
end

function getModelDisplayName(model, unit)
    if unit.isSingleModel or useDecorativeNames then
        if unit.decorativeName ~= nil and unit.decorativeName ~= "" then
            return unit.decorativeName
        else
            return model.name
        end
    end

    return model.name
end

function getModelTags(model, unit)
    local tags = { "uuid:"..unit.uuid }

    if unit.woundTrack ~= nil then
        for key,_ in pairs(unit.woundTrack) do
            if key == model.name then table.insert(tags, "wt:"..model.name)
            -- this is a special case for Armigers (i.e. units that have multiple of the same model that has a wound track)
            -- where the data source creator named the profile in the plural ("Armigers")
            elseif key == model.name.."s" then table.insert(tags, "wt:"..model.name.."s") end
        end
    end

    return tags
end

-- Combine abilities and rules and format them properly to be displayed in a unit's datasheet
function getFormattedAbilities(abilities, rules)
    local abilitiesString = table.concat(map(abilities, function (ability)
        ability.name = ability.name:gsub("%[", "("):gsub("%]", ")") -- try not to break formatting

        return interpolate(ABILITITY_STRING_TEMPLATE, ability)
    end), ",\n\t\t")

    if #rules > 0 then
        abilitiesString = abilitiesString..
                            (len(abilities) > 0 and ",\n\t\t" or "")..
                            interpolate(ABILITITY_STRING_TEMPLATE, {
                                name="Additional Rules\n(see the books)",
                                desc = table.concat(map(rules, |rule| (rule:gsub("%[", "("):gsub("%]", ")"))), ", ")-- try not to break formatting
                            })
    end

    return abilitiesString
end

-- chooses a random model from the given array
-- technically this is a general method that could be used for selecting
-- a random value from any array
function chooseRandomModel(modelArray)
    if #modelArray == 1 then return modelArray[1] end
    if modelArray == nil or #modelArray == 0 then return nil end

    return modelArray[math.random(1, #modelArray)] -- both inclusive
end

-- spawns a model from the given data set
function createModelFromData(modelData, x, z, y, leaderModelScript)
    if leaderModelScript ~= nil then
        modelData = clone(modelData) -- prevent weird things with tables being treated as references
        table.insert(modelData.Tags, "leaderModel")
        modelData.XmlUI = YELLOW_STORAGE_XML
        modelData.LuaScript = leaderModelScript
    end

    local spawnData = {
        data = modelData,
        position = {
            x = x,
            y = MODEL_PLACEMENT_Y+y,
            z = z
        },
        rotation = { x=0, y=180, z=0 }, -- this seems right for most (but not all models)
    }

    spawnObjectData(spawnData)
end

-- finds the appropriate characteristic profile for the given model in the given unit
function getProfileForModel(model, unit)
    local otherModelsProfile = nil

    -- This is for compatibility with Crusade F2P. Crusade F2P generates a slightly tweaked form of
    -- army list where the profiles table is indexed by a unique ID instead of by name, and models then
    -- have a profileID property to precisely identify the correct profile, instead of relying on name
    -- matching. That allows multiple profiles to have the same name, which can be useful where
    -- identically-named models differ in wargear that alters their characteristics. This code
    -- is fine to execute against vanilla YellowScribe JSON as it'll simply never find a profileID.
    if model.profileID ~= nil then
        return unit.modelProfiles[model.profileID];
    end

    for _,profile in pairs(unit.modelProfiles) do
        if profile.name == model.name then
            return profile
        end

        if profile.name:lower() == "other models" then
            otherModelsProfile = profile
        end
    end
    -- if there arent any exactly matching profiles, try a more fuzzy search (both ways - profile name
    -- contains model name, and model name contains profile name)
    for _,profile in pairs(unit.modelProfiles) do
        local found = profile.name:find(model.name, 1, true) -- search for plain text (ie not pattern)
        if found ~= nil then return profile end

        found = model.name:find(profile.name, 1, true)
        if found ~= nil then return profile end
    end
    -- In 10th edition, at least one unit has "Other Models" as a catch-all
    if otherModelsProfile then
        return otherModelsProfile
    end
    -- if there arent any matching profiles, assume there's only one profile for every model in the unit
    for _,profile in pairs(unit.modelProfiles) do return profile end

    -- returns nil if not found
end

-- gets a model's description
function buildModelDescription(model, unit, modelProfile)
    return  formatCharDesc(modelProfile, unit)..
            formatWeaponDesc(model, unit, modelProfile ~= nil)..
            formatAbilityDesc(model, unit, modelProfile ~= nil)..
            formatPsychicDesc(model, unit, modelProfile ~= nil)
end

-- formats the characteristics section in a model's description
function formatCharDesc(modelProfile, unit)
    if modelProfile == nil then return "" end -- handles the rare case where a model just doesnt have a profile (eg Mekboy Workshop)

    local charHeadingString,charValueString = "[56f442]",""
    local currentChar = 1
    local woundTrack

    if unit.woundTrack ~= nil then
        if unit.woundTrack[modelProfile.name] ~= nil then
            woundTrack = map(unit.woundTrack[modelProfile.name], |v| v) -- make it array-like
        elseif len(unit.woundTrack) == 1 then
            for _,wt in pairs(unit.woundTrack) do
                woundTrack = map(wt, |v| v)
            end
        end
    end

    for heading,value in pairs(modelProfile) do
        if heading ~= "name" then
            if value == "*" and woundTrack ~= nil then
                value = woundTrack[1][currentChar]
                charValueString = charValueString..interpolate(DEFAULT_BRACKET_VALUE_TEMPLATE, { val=value }).."   "
                currentChar = currentChar + 1
            else
                charValueString = charValueString..(value == "-" and "  "..value or value).."   "
            end

            charHeadingString = charHeadingString..formatHeading(heading, value)
        end
    end

    charHeadingString = charHeadingString.."[-]\n"

    return charHeadingString..charValueString.."[-][-]" -- the double brackets at the end helps us to update brakcets if the unit has them
end

-- formats the heading line for the characteristics section in a model's description
-- the spacing is based on the values given so that they line up properly
function formatHeading(heading, value)
    local spacing = value:gsub("\\",""):len()-heading:len()

    if heading == "ws" or heading == "m" or heading =="a" then
        spacing = spacing + 2
    else
        spacing = spacing + 3
    end

    if (heading == "m" and value:len() > 2) or ((heading == "a" or heading == "s" or heading == "t" or heading == "w") and value:len() > 1) then
        if heading == "m" and value ~= "-" and value:find('%-') ~= nil then
            heading = heading.."   "
        end

        heading = " "..heading
    end

    return capitalize(heading)..string.rep(" ", spacing)
end

-- decides whether to fully capitalize or (in the case of ld and sv) titlecase a string
function capitalize(heading)
    if heading == "ld" or heading == "sv" then return titlecase(heading) end
    return heading:upper()
end

-- only use this for changing ld and sv to Ld and Sv
function titlecase(s)
    return s:gsub("^(%w)", |a| a:upper())
end

-- formats the string for the weapons section in a model's description
function formatWeaponDesc(model, unit, needSpacingBefore)
    if #model.weapons == 0 then return "" end

    local rangedWeapons = filter(model.weapons, |weapon| unit.weapons[weapon.name].range:lower() ~= "melee")
    local meleeWeapons = filter(model.weapons, |weapon| unit.weapons[weapon.name].range:lower() == "melee")

    local weapons = needSpacingBefore and "\n\n" or ""

    if #rangedWeapons > 0 then
        weapons = weapons .. "[e85545]Ranged weapons[-]"

        for _,weapon in pairs(rangedWeapons) do
            weapons = weapons.."\n"..formatWeapon(unit.weapons[weapon.name], weapon.number)
        end
    end

    if #meleeWeapons > 0 then
        if #rangedWeapons > 0 then weapons = weapons .. "\n\n" end
        weapons = weapons .. "[e85545]Melee weapons[-]"

        for _,weapon in pairs(meleeWeapons) do
            weapons = weapons.."\n"..formatWeapon(unit.weapons[weapon.name], weapon.number)
        end
    end

    return weapons
end

-- formats the string for a weapon entry in a model's description
function formatWeapon(weaponProfile, number)
    weaponName = number == 1 and weaponProfile.name or (number.."x "..weaponProfile.name)
    if edition == "10e" then
        if weaponProfile.range:lower() == "melee" then
            return  interpolate(MELEE_WEAPON_TEMPLATE_10E, {
                name = weaponName,
                a = weaponProfile.a,
                ws = weaponProfile.bsws,
                s = weaponProfile.s,
                ap = weaponProfile.ap,
                d = weaponProfile.d,
                ability = weaponProfile.shortAbilities == "-" and "" or "[" .. weaponProfile.shortAbilities .. "]"
            })
        else
            return  interpolate(RANGED_WEAPON_TEMPLATE_10E, {
                name = weaponName,
                range = weaponProfile.range,
                a = weaponProfile.a,
                bs = weaponProfile.bsws,
                s = weaponProfile.s,
                ap = weaponProfile.ap,
                d = weaponProfile.d,
                ability = weaponProfile.shortAbilities == "-" and "" or "[" .. weaponProfile.shortAbilities .. "]"
            })
        end
    else
        return  interpolate(WEAPON_TEMPLATE_9E, {
            name = weaponName,
            rangeAndType = (weaponProfile.range == "Melee") and "Melee" or weaponProfile.range.." "..weaponProfile.type,
            s = weaponProfile.s,
            ap = weaponProfile.ap,
            d = weaponProfile.d,
            ability = weaponProfile.abilities == "-" and "" or "Sp:*"
        })
    end
end

-- formats the string for the abilities section in a model's description
function formatAbilityDesc(model, unit, needSpacingBefore)
    if #model.abilities == 0 then return "" end

    return ((needSpacingBefore or #model.weapons > 0) and "\n\n" or "").."[dc61ed]Abilities[-]\n"..table.concat(model.abilities, "\n")
end


function formatPsychicDesc(model, unit)
    if unit.powersKnown == nil or #unit.powersKnown == 0 then return "" end

    return ((needSpacingBefore or #model.weapons > 0 or #model.abilities > 0) and "\n\n" or "")..
            "[5785fe]Psychic Powers[-]\n"..table.concat(map(unit.powersKnown, |power| interpolate(PSYCHIC_POWER_TEMPLATE, {
                name = power.name,
                warpCharge = power.warpCharge,
                range = power.range
            })), "\n")
end


function deleteAllObjectsInCreationZone()
    local deletionZone = getObjectFromGUID(DELETION_ZONE_GUID)

    if deletionZone == nil then return end

    for _,object in ipairs(deletionZone.getObjects()) do
        if object ~= armyBoard and object.getGUID() ~= YELLOW_STORAGE_GUID then
            object.setLuaScript("") -- prevent unintended consequences of destruction
            object.destruct() -- at this point the object is a different object because we reloaded it
        end
    end
end








--[[ INITIALIZATION HELPER FUNCTIONS ]]--



function showWindow(name)
    -- delay in case of update
    Wait.frames(function ()
        UI.setXml(self.UI.getXml())

        Wait.frames(function ()
            UI.setAttribute("mainPanel", "active", true)
            UI.show(name)
        end, 2)
    end, 2)
end






--[[ LOADING FROM GLOBAL UI ]]--


function loadEditedArmy(data)
    self.clearButtons()

    army = data.armyData
    edition = data.edition
    uiHeight = data.uiHeight
    uiWidth = data.uiWidth
    useDecorativeNames = data.useDecorativeNames
    --YELLOW_STORAGE_SCRIPT = armyData.baseScript -- yes I know I'm assigning a new value to something I marked as a constant, sue me

    local formattedArmyData = getLoadedArmyXML(data.order)

    if formattedArmyData.totalHeight < 3000 then
        self.UI.setAttributes("loadedScrollContainer", {
            noScrollbars = true,
            width = 2030
        })
    else
        self.UI.setAttributes("loadedScrollContainer", {
            noScrollbars = false,
            width = 2050
        })
    end

    self.UI.setAttribute("loadedContainer", "height", formattedArmyData.totalHeight)--formattedArmyData.totalHeight
    self.UI.setValue("loadedContainer", formattedArmyData.xml)
    self.UI.setAttribute("postLoading", "active", "false")
    self.UI.hide("postLoading")
    self.UI.setClass("mainPanel", "hiddenBigWindow")

    self.createButton(CREATE_ARMY_BUTTON)

    Wait.frames(function ()
        UI.hide("mainPanel")
        self.UI.setAttribute("loadedScrollContainer", "active", "true")
        self.UI.setXml(self.UI.getXml())
    end, 2)
end

function getLoadedArmyXML(order)
    local xmlString = ""
    local modelInUnitCount,modelDataForXML,currentUnitContainerHeight,totalUnitContainerHeight
    local maxModelHeight,totalHeight = 0,0

    for _,uuid in ipairs(order) do
        local unit = army[uuid]
        local modelGroupString,unitDataString = "",""

        modelInUnitCount = 0
        currentUnitContainerHeight = 0
        totalUnitContainerHeight = 50 -- name

        for modelID,model in pairs(unit.models.models) do
            modelInUnitCount = modelInUnitCount + 1
            modelDataForXML = getModelDataForXML(uuid, modelID, model, unit.weapons)
            modelGroupString = modelGroupString..interpolate(uiTemplates.MODEL_CONTAINER, modelDataForXML)

            if modelDataForXML.height > maxModelHeight then
                maxModelHeight = modelDataForXML.height
                currentUnitContainerHeight = modelDataForXML.height
            end

            if modelInUnitCount % 4 == 0 then
                unitDataString = unitDataString..interpolate(uiTemplates.MODEL_GROUPING_CONTAINER, {
                    modelGroups = modelGroupString,
                    width = "1000",
                    height = maxModelHeight
                })

                modelInUnitCount = 0
                maxModelHeight = 0
                modelGroupString = ""
                totalUnitContainerHeight = totalUnitContainerHeight + currentUnitContainerHeight + 20 -- spacing
            end
        end

        if modelInUnitCount ~= 0 then
            unitDataString = unitDataString..interpolate(uiTemplates.MODEL_GROUPING_CONTAINER, {
                modelGroups = modelGroupString,
                width = tostring(250 * modelInUnitCount),
                height = maxModelHeight
            })
            maxModelHeight = 0
            totalUnitContainerHeight = totalUnitContainerHeight + currentUnitContainerHeight
        end

        totalHeight = totalHeight + totalUnitContainerHeight + 100 -- spacing

        xmlString = xmlString..interpolate(uiTemplates.UNIT_CONTAINER, {
            unitName = unit.decorativeName and unit.decorativeName or unit.name,
            unitData = unitDataString,
            height = totalUnitContainerHeight
        })
    end

    return { xml = xmlString, totalHeight = totalHeight }
end


function getModelDataForXML(unitID, modelID, model, characteristicProfiles)
    local weaponSection,abilitiesSection = "",""
    local totalCardHeight = 40 -- name

    model.weapons = table.sort(model.weapons, function (weaponA,weaponB) --combine(model.weapons, model.assignedWeapons)
        if edition == "10e" then
            local rangeA = trim(characteristicProfiles[weaponA.name].range):gsub("%s+%d?D?d?%/?%d+$", ""):lower()
            local rangeB = trim(characteristicProfiles[weaponB.name].range):gsub("%s+%d?D?d?%/?%d+$", ""):lower()
            local aIsMelee = rangeA == "melee" and 1 or 0
            local bIsMelee = rangeB == "melee" and 1 or 0

            if aIsMelee == bIsMelee then return weaponA.name < weaponB.name end
            return aIsMelee < bIsMelee
        else
            local typeA = trim(characteristicProfiles[weaponA.name].type):gsub("%s+%d?D?d?%/?%d+$", ""):lower()
            local typeB = trim(characteristicProfiles[weaponB.name].type):gsub("%s+%d?D?d?%/?%d+$", ""):lower()
            local typeAVal = WEAPON_TYPE_VALUES[typeA] == nil and 0 or WEAPON_TYPE_VALUES[typeA]
            local typeBVal = WEAPON_TYPE_VALUES[typeB] == nil and 0 or WEAPON_TYPE_VALUES[typeB]

            if typeAVal == typeBVal then return weaponA.name < weaponB.name end
            return typeAVal < typeBVal
        end
    end)

    if model.weapons ~= nil and #model.weapons > 0 then
        weaponSection = interpolate(uiTemplates.MODEL_DATA, {
            dataType = "Weapons:",
            data = table.concat(map(model.weapons,
                                    |weapon| weapon.number == 1 and weapon.name or (weapon.number.."x "..weapon.name))
                                ,"\n"),
            height = 37 * #model.weapons
        })
        totalCardHeight = totalCardHeight + (37 * #model.weapons) + (#model.abilities > 0 and 55 or 60) -- title and spacer
    end

    if #model.abilities > 0 then
        abilitiesSection = interpolate(uiTemplates.MODEL_DATA, {
            dataType = "Abilities:",
            data = table.concat(model.abilities, "\n"),
            height = 37 * #model.abilities
        })
        totalCardHeight = totalCardHeight + (37 * #model.abilities) + 60 -- title and spacer
    end

    return {
        modelName = model.name,
        numberString = model.number > 1 and (tostring(model.number).."x ") or "",
        weapons = weaponSection,
        abilities = abilitiesSection,
        unitID = unitID,
        modelID = modelID,
        height = totalCardHeight
    }
end











--[[ UTILITY FUNCTIONS ]]--


function interpolate(templateString, replacementValues)
    return (templateString:gsub('($%b{})', |w| replacementValues[w:sub(3, -2)] or w)) -- extra parenthesis to prevent double return from gsub
end

function combine(tab1, tab2)
    if tab1 == nil then return clone(tab2) end
    if tab2 == nil then return clone(tab1) end

    local newTab = clone(tab1)

    for _,val in pairs(clone(tab2)) do
        table.insert(newTab, val)
    end

    return newTab
end

function clone(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[clone(orig_key)] = clone(orig_value)
        end
        setmetatable(copy, clone(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

function split(s, delimiter)
    local result = {};
    for match in (s..delimiter):gmatch("(.-)%"..delimiter) do
        table.insert(result, match);
    end
    return result;
end

function filter(t, filterFunc)
    local out = {}

    for k, v in pairs(clone(t)) do
      if filterFunc(v, k, t) then table.insert(out,v) end
    end

    return out
end

function includes (tab, val, checkKey)
    for index, value in ipairs(tab) do
        if checkKey ~= nil then
            if value[checkKey] == val[checkKey] then
                return true
            end
        else
            if value == val then
                return true
            end
        end
    end

    return false
end

function find(tab, val)
    for index, value in ipairs(tab) do
        if value == val then
            return index
        end
    end

    return -1
end

function filterKeepKeys(t, filterFunc)
    local out = {}

    for k, v in pairs(clone(t)) do
      if filterFunc(v, k, t) then out[k] = v end
    end

    return out
end

function map(t, mapFunc)
    local out = {}

    for k,v in pairs(clone(t)) do
        table.insert(out, mapFunc(v,k))
    end

    return out
end

function len(t)
    local count = 0

    for _,_ in pairs(t) do
        count = count + 1
    end

    return count
end

function trim(s)
    return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'
end

-- this should only ever be used with one dimensional tables
function tableToFlatString(t)
    return tableToString(t, ", ")
end

-- this is not a particularly robust solution, it is only really for my purposes in this script
-- thus, I very much do not recommend anyone copy this
-- note to self: can make it recursive to traverse multi-dimensional tables but eh
-- warnings:
--      this assumes a table is array-like if the key "1" exists,
--      this assumes all values are strings
function tableToString(t, delimiter, bracketsOnNewLine, extraTabbing, tabBeforeFirstElement)
    local out = "{ "
    local arrayLike = t[1] ~= nil

    if bracketsOnNewLine ~= nil and bracketsOnNewLine then
        out = out.."\n"..(tabBeforeFirstElement ~= nil and tabBeforeFirstElement or "")
    end

    out = out..table.concat(map(t, function (v,k)
        if arrayLike then return v end
        return k..'="'..v:gsub('"', '\\"')..'"'
    end), delimiter)

    if bracketsOnNewLine ~= nil and bracketsOnNewLine then
        return out.."\n"..(extraTabbing ~= nil and extraTabbing or "").."}"
    end

    return out.." }"
end

function removeModelByID(unitID, modelID)
    loadedData[unitID].models.models[modelID] = nil
end

function sortModels(tbl, sortFunction)
    local keys = {}

    for key in pairs(tbl) do
        table.insert(keys, key)
    end

    table.sort(keys, function(a, b)
        return sortFunction(tbl[a], tbl[b])
    end)

    return keys
end

function uuid()
    local template ='xxxxxxxx'
    return string.gsub(template, '[xy]', function (c)
        local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb)
        return string.format('%x', v)
    end)
end

function removeModelByID(unitID, modelID)
    loadedData[unitID].models.models[modelID] = nil
end

function sortModels(tbl, sortFunction)
    local keys = {}

    for key in pairs(tbl) do
        table.insert(keys, key)
    end

    table.sort(keys, function(a, b)
        return sortFunction(tbl[a], tbl[b])
    end)

    return keys
end
end)
__bundle_register("vscode/console", function(require, _LOADED, __bundle_register, __bundle_modules)
require("Console/console++")

-- function prototype
function onExternalCommand(command) end

-- Overwrite onChat function if you rather be handled by onExternalMessage
-- function onChat(message, player) end

function onExternalMessage(data)
  if data.input ~= nil then onExternalCommand(data.input) end
  if data.command ~= nil then
    local hostPlayer
    local players = getSeatedPlayers()
    for key, value in pairs(players) do
      if Player[value].host then
        hostPlayer = Player[value]
      end
    end
    if data.command ~= '' then
      local command = ''
      local command_function = nil
      local parameters = {hostPlayer}
      local requires_admin = false
      local command_mode = console.in_command_mode[hostPlayer.steam_id]
      if command_mode and console.active then
          command, command_function, parameters, requires_admin = console.get_command(data.command, hostPlayer)
      elseif data.command:sub(1, 1) == console.command_char and console.active then
          if data.command:len() > 1 then
              command, command_function, parameters, requires_admin = console.get_command(data.command:sub(2), hostPlayer)
          else
              command, command_function, parameters, requires_admin = console.get_command(console.command_char, hostPlayer)
          end
      else
          for i, f in ipairs(console.validation_functions) do
              local valid, response = f(data.command)
              if response == nil then response = '' end
              if not valid then
                  printToColor(response, hostPlayer.color, console.invalid_color)
                  return false
              end
          end
          return true
      end
      if console.active then
          if command_function and (hostPlayer.admin or not requires_admin) then
              if command_mode then
                  data.command = console.command_char .. console.command_char .. data.command
              end
              local response, mute = command_function(unpack(parameters))
              if response ~= nil or mute ~= nil then
                  if not mute then
                      printToColor('\n'..data.command, hostPlayer.color, console.command_color)
                  end
                  if response then
                      printToColor(response, hostPlayer.color, console.output_color)
                  end
              end
              if console.in_command_mode[hostPlayer.steam_id] then console.display_prompt(hostPlayer) end
              return false
          else
              printToColor('\n'..data.command, hostPlayer.color, console.command_color)
              printToColor(console.error_bb .. "<command '" .. command .. "' not found>[-]", hostPlayer.color, console.output_color)
              return false
          end
      end
    end
  end
end

end)
__bundle_register("Console/console++", function(require, _LOADED, __bundle_register, __bundle_modules)
require("Console/console")

if not console.plusplus then
    console.plusplus = true

    -- Change these values as you wish
    console.seperator         = '/'
    console.wildcard          = '*'
    console.literal           = '`'  -- string parameters will be treated as paths where apt unless prefixed with this
    console.result            = '~'  -- refers to the most recently returned result from a call
    console.command_seperator = ';'  -- used in batch files to seperate commands
    console.indent            = '  '
    console.crop_string_at = 20
    console.builtin_path = 'sys'
    console.table_bb    = '[EEDD88]'
    console.hidden_bb   = '[DDAAAA]'
    console.function_bb = '[AADDAA]'
    console.value_bb    = '[88EE88]'
    console.boolean_bb  = '[CCCCFF]'
    console.object_bb   = '[CCBBCC]'
    console.guid_bb     = '[BBBBBB]'

    console.autoexec         = ''
    console.autoexec_options = '-s'

    -- Exposed methods:

    function console.hide_globals(label)
        -- all globals present when you call this will be hidden under <label> (unless built-in or already hidden)
        local hidden = {}
        for global, _ in pairs(_G) do
            local found = false
            for _, globals in pairs(console.hidden_globals) do
                if globals[global] then
                    found = true
                    break
                end
            end
            if not found then
                table.insert(hidden, global)
            end
        end
        if console.hidden_globals[label] == nil then
            console.hidden_globals[label] = {}
        end
        for _, global in ipairs(hidden) do
            console.hidden_globals[label][global] = true
        end
    end

    function console.load()
        -- call this function in an onLoad event to enable the autoexec
        console.cd = console.seperator
        for _, player in pairs(getSeatedPlayers()) do
            if Player[player].admin then
                console.commands['exec'].command_function(Player[player], console.seperator..'console'..console.seperator..'autoexec', console.autoexec_options)
                break
            end
        end
    end

    function console.update()
        -- call this function in an onUpdate event to enable the watch list
        if console.watch_list and not console.watch_list_paused then
            for variable, watch in pairs(console.watch_list) do
                if watch.throttle == 0 or watch.last_check + watch.throttle < os.clock() then
                    watch.last_check = os.clock()
                    local node, id, parent, found
                    if watch.is_guid then
                        node = getObjectFromGUID(variable)
                        found = tostring(node) ~= 'null'
                    else
                        node, id, parent, found = console.node_from_path(variable)
                    end
                    if node ~= nil and found then
                        if type(node) == 'userdata' then
                            if tostring(node) ~= 'null' then
                                local p = function (x) return math.floor(x * 100) * 0.01 end
                                local r = function (x) return math.floor(x + 0.5) end
                                local position = node.getPosition()
                                local rotation = node.getRotation()
                                if p(position.x) ~= p(watch.position.x) or r(rotation.x) ~= r(watch.rotation.x) or
                                   p(position.y) ~= p(watch.position.y) or r(rotation.y) ~= r(watch.rotation.y) or
                                   p(position.z) ~= p(watch.position.z) or r(rotation.z) ~= r(watch.rotation.z) then
                                   watch.position = position
                                   watch.rotation = rotation
                                   node = ' ∡ '..r(rotation.x)..' '..r(rotation.y)..' '..r(rotation.z) ..
                                        console.boolean_bb..'   ⊞  '..p(position.x)..'   '..p(position.y)..'   '..p(position.z)
                                   if watch.is_guid then
                                       variable = console.format_guid(variable)
                                   else
                                       variable = console.object_bb .. variable .. '[-]'
                                   end
                                   printToColor(variable .. console.value_bb .. node .. '[-]', watch.player, console.output_color)
                                end
                            end
                        elseif type(node) == 'function' then
                            local result = node(unpack(watch.parameters))
                            if watch.property and (type(result) == 'table' or type(result) == 'userdata') then
                                result = result[watch.property]
                                if type(result) == 'function' then
                                    result = result()
                                end
                            end
                            if result ~= watch.value then
                                watch.value = result
                                result = tostring(result)
                                if result:len() > console.crop_string_at then result = result:sub(1, console.crop_string_at) .. '...' end
                                if result:len() == 6 and watch.label:lower():find('guid') then result = console.format_guid(result) end
                                printToColor(watch.label .. console.value_bb .. result .. '[-]', watch.player, console.output_color)
                            end
                        else
                            if node ~= watch.value then
                                watch.value = node
                                if type(node) == 'boolean' then
                                    if node then
                                        node = 'true'
                                    else
                                        node = 'false'
                                    end
                                elseif type(node) == 'string' then
                                    if node:len() > console.crop_string_at then node = node:sub(1, console.crop_string_at):gsub('\n', ' ') .. '...' end
                                end
                                printToColor(variable .. ': ' .. console.value_bb .. node .. '[-]', watch.player, console.output_color)
                            end
                        end
                    end
                end
            end
        end
    end

    -- simple swear-blocking validation
    console.add_validation_function(
        function (message)
            local message = message:lower()
            for i, bad_word in pairs({'fuck', 'cunt'}) do
                if message:find(bad_word) then
                    return false, "No swearing!"
                end
            end
            return true
        end
    )

    -- End of exposed methods.  You shouldn't need to interact with anything below (under normal circumstances)


    -- override default prompt with one which displays current table
    function console.display_prompt(player)
        printToColor(console.cd .. ' ' .. console.command_char..console.command_char, player.color, console.prompt_color)
    end


    -- console++ follows

    console.cd = console.seperator
    console.hidden_globals = {}
    console.hide_globals(console.builtin_path)

    function console.is_hidden(label)
        for _, globals in pairs(console.hidden_globals) do
            if globals[label] then
                return true
            end
        end
        return false
    end

    function console.escape_bb(s)
        local s = tostring(s)
        if s == '' then
            return ''
        else
            local r = ''
            for c = 1, s:len() do
                local char = s:sub(c, c)
                if char == '[' then
                    r = r .. '[\u{200B}'
                elseif char == ']' then
                    r = r .. '\u{200B}]'
                else
                    r = r .. char
                end
            end
            return r
        end
    end

    function console.format_guid(guid)
        return console.guid_bb .. '⁅' .. guid .. '⁆[-]'
    end

    function console.fill_path(path)
        local path = path
        local filter = nil
        if path == nil then
            return console.cd, filter
        end
        local c = path:len()
        if path:sub(c) ~= console.seperator then
            local found = false
            while c > 0 do
                local char = path:sub(c, c)
                if char == console.wildcard then
                    found = true
                elseif char == console.seperator then
                    break
                end
                c = c - 1
            end
            if found then
                filter = '^'
                for i = c + 1, path:len() do
                    local char = path:sub(i, i)
                    if char == console.wildcard then
                        filter = filter .. '.*'
                    else
                        filter = filter .. char
                    end
                end
                filter = filter .. '$'
                path = path:sub(1, c)
            end
        end
        if path:sub(1,1) == console.seperator then
            return path, filter
        else
            return console.cd .. path, filter
        end
    end

    function console.node_from_path(path)
        local node = _G
        local id = {''}
        local parent = {nil}
        local found = true
        local depth = 0
        local stack = {}
        local hidden = nil
        local ends_with_table = {true}
        if path == 'true' then
            node = true
        elseif path == 'false' then
            node = false
        elseif path ~= console.seperator then
            for i, part in ipairs(console.split(path, console.seperator)) do
                if part == '..' then
                    if depth > 0 then
                        node = table.remove(parent)
                        table.remove(id)
                        table.remove(stack)
                        table.remove(ends_with_table)
                        depth = depth - 1
                    end
                elseif part == '.' then
                    ; -- do nothing, . = where we are
                elseif part == console.result then
                    table.insert(parent, node)
                    table.insert(id, part)
                    table.insert(stack, part)
                    node = console.returned_value
                    table.insert(ends_with_table, type(node) == 'table')
                    depth = depth + 1
                elseif node[part] ~= nil then
                    table.insert(parent, node)
                    table.insert(id, part)
                    table.insert(stack, part)
                    node = node[part]
                    table.insert(ends_with_table, type(node) == 'table')
                    depth = depth + 1
                elseif node == _G and console.hidden_globals[part] then
                    hidden = console.hidden_globals[part]
                else
                    table.insert(id, part)
                    found = false
                    break
                end
            end
        end
        path = ''
        for i, part in ipairs(stack) do
            path = path .. console.seperator .. part
        end
        if table.remove(ends_with_table) then
            path = path .. console.seperator
        end
        return node, table.remove(id), table.remove(parent), found, path, hidden
    end


    -- commands

    console.add_admin_command('cd', '[<table>]',
        'Display current table or change current table',
        function (player, path)
            if path == nil then
                return console.cd
            else
                path = tostring(path)
            end
            local location = console.fill_path(path)
            local node, id, parent, found, location = console.node_from_path(location)
            local text = nil
            if node ~= nil and found and type(node) == 'table' then
                console.cd = location
                if not console.in_command_mode[player.steam_id] then text = console.cd end
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text, false
        end
    )
    console.add_admin_command('cd..', '', 'Change current table to parent table.', 'cd', {'..'})

    console.add_admin_command('ls', '[' .. console.option .. '?afotv] [' .. console.option .. 'r[#]] [<table>]',
        'Display variables in current table or specified table',
        function (player, ...)
            local help_details = console.header_bb .. 'Options[-]\n' ..
                'Show:\n '..console.option..'f functions\n '..console.option..'o objects\n '..
                console.option..'v variables (defaults to on)\n '..console.option..'t tables (defaults to on)\n '..
                console.option..'a all\n\n' ..console.option..'r[#] recurse [# layers if specified]'
            local path = console.cd
            local display_functions = false
            local display_objects = false
            local display_variables = false
            local display_tables = false
            local display_all = false
            local recursions_left = 0
            for i, arg in ipairs({...}) do
                arg = tostring(arg)
                if arg:len() > 1 and arg:sub(1,1) == console.option then
                    local c = 2
                    while c <= arg:len() do
                        local option = arg:sub(c,c)
                        if option == 'f' then
                            display_functions = not display_functions
                        elseif option == 'o' then
                            display_objects = not display_objects
                        elseif option == 'v' then
                            display_variables = not display_variables
                        elseif option == 't' then
                            display_tables = not display_tables
                        elseif option == 'a' then
                            display_all = not display_all
                        elseif option == 'r' then
                            local n = ''
                            local j = c + 1
                            while j <= arg:len() do
                                local char = arg:sub(j, j)
                                if char:match('%d') then
                                    n = n .. char
                                else
                                    break
                                end
                                j = j + 1
                            end
                            c = j - 1
                            if n == '' then
                                recursions_left = 20
                            else
                                recursions_left = tonumber(n)
                            end
                        elseif option == '?' or option == 'h' then
                            return help_details
                        else
                            return console.error_bb .. "<option '" .. console.option .. option .. "' not recognized>[-]\n"
                        end
                        c = c + 1
                    end
                else
                    path = arg
                end
            end
            local default_variables = not (display_tables or display_objects or display_functions or display_variables)
            if display_functions or display_objects or display_variables then
                display_tables = not display_tables
            end
            if display_all then
                display_functions = true
                display_objects = true
                display_variables = true
                display_tables = true
            elseif default_variables then
                display_functions = false
                display_objects = false
                display_variables = true
                display_tables = true
            end
            local location, filter = console.fill_path(path)
            return console.ls(player, location, filter, display_functions, display_objects, display_variables, display_tables, recursions_left)
        end
    )
    console.add_admin_command('dir', nil, nil, 'ls')
    console.add_admin_command(console.result, '', "Calls 'ls "..console.option.."a "..console.result.."'", 'ls', {console.option..'a', console.result})

    function console.ls(player, path, filter, display_functions, display_objects, display_variables, display_tables, recursions_left, indent)
        local text = ''
        local indent = indent or ''
        local node, id, parent, found, location, hidden = console.node_from_path(path)
        local paths = {}
        if node ~= nil and (found or hidden) then
            if type(node) == 'table' then
                local tables = {}
                local entries = {}
                for k, v in pairs(node) do
                    if (node ~= _G or (not hidden and not console.is_hidden(k)) or (hidden and hidden[k])) and (filter == nil or k:match(filter)) then
                        if type(v) == 'table' then
                            local t = console.table_bb .. k .. '[-]'
                            table.insert(tables, t)
                            paths[t] = path .. console.seperator .. k
                        else
                            if type(v) == 'function' then
                                if display_functions then
                                    table.insert(entries, console.function_bb .. k .. '[-]()')
                                end
                            elseif type(v) == 'userdata' then
                                if display_objects then
                                    local tag = tostring(v)
                                    if tag:find('(LuaGameObjectScript)') and not tag:gsub('(LuaGameObjectScript)',''):find('Script ') then
                                        tag = v.tag .. ' ' .. console.format_guid(v.getGUID())
                                    end
                                    if type(k) == 'number' and math.floor(k) == k then k = string.format('%04d', k) end
                                    table.insert(entries, console.object_bb .. k .. '[-]: '  .. tag)
                                end
                            elseif display_variables then
                                if type(v) == 'boolean' then
                                    if v then
                                        v = 'true'
                                    else
                                        v = 'false'
                                    end
                                    table.insert(entries, k .. ': ' .. console.boolean_bb .. v .. '[-]')
                                else
                                    local is_guid = false
                                    if type(v) == 'string' then
                                        if v:len()> console.crop_string_at then v = v:sub(1, console.crop_string_at):gsub('\n', ' ') .. '...' end
                                        if type(k) == 'string' and k:lower():find('guid') and v:len() == 6 then
                                            is_guid = true
                                        end
                                    end
                                    if is_guid then
                                        table.insert(entries, k .. ': ' .. console.format_guid(v) .. '[-]')
                                    else
                                        table.insert(entries, k .. ': ' .. console.value_bb .. console.escape_bb(v) .. '[-]')
                                    end
                                end
                            end
                        end
                    end
                end
                local cmp = function (a, b)
                    if not a then
                        return true
                    elseif not b then
                        return false
                    else
                        local la = a:len()
                        local lb = b:len()
                        local c = 1
                        repeat
                            if c > la and c <= lb then
                                return true
                            elseif c > lb and c <= la then
                                return false
                            elseif c > la then
                                return false
                            else
                                local ba = a:sub(c, c):byte()
                                local bb = b:sub(c, c):byte()
                                if ba < bb then
                                    return true
                                elseif bb < ba then
                                    return false
                                end
                            end
                            c = c + 1
                        until false
                    end
                end
                table.sort(tables, cmp)
                table.sort(entries, cmp)
                local cr = ''
                if display_tables then
                    for i, t in ipairs(tables) do
                        text = text .. cr .. indent .. t .. console.seperator
                        if recursions_left ~= 0 then
                            text = text .. '\n' .. console.ls(player, paths[t], filter,
                                display_functions, display_objects, display_variables, display_tables,
                                recursions_left-1, indent..console.indent)
                        end
                        cr = '\n'
                    end
                    if node == _G and not hidden then
                        for label, _ in pairs(console.hidden_globals) do
                            if (filter == nil or label:match(filter)) then -- and label ~= console.builtin_path
                                text = text .. cr .. indent .. console.hidden_bb .. label .. console.seperator .. '[-]'
                                cr = '\n'
                            end
                        end
                    end
                end
                for _, entry in ipairs(entries) do
                    text = text .. cr .. indent .. entry
                    cr = '\n'
                end
            elseif type(node) == 'userdata' then
                local tag = tostring(node)
                if tag ~= 'null' and tag:find('(LuaGameObjectScript)') and not tag:gsub('(LuaGameObjectScript)',''):find('Script ') then
                    tag = node.tag .. ' ' .. console.format_guid(node.getGUID())
                end
                text = indent .. console.object_bb .. id .. '[-]: ' .. tag
            elseif type(node) == 'function' then
                text = indent .. console.function_bb .. id .. '[-]()'
            elseif type(node) == 'boolean' then
                if node then
                    text = indent .. id .. ': ' .. console.boolean_bb .. 'true[-]'
                else
                    text = indent .. id .. ': ' .. console.boolean_bb .. 'false[-]'
                end
            else
                if type(id) == 'string' and id:lower():find('guid') and type(node) == 'string' and node:len() == 6 then
                    text = indent .. id .. ': ' .. console.format_guid(node) .. '[-]'
                else
                    text = indent .. id .. ': ' .. console.value_bb .. console.escape_bb(node) .. '[-]'
                end
            end
        else
            text = indent .. console.error_bb .. '<not found>[-]'
        end
        return text
    end

    console.add_admin_command('call', '<function> [<parameter>...]',
        'Call function with parameters and display result.',
        function (player, ...)
            local path = nil
            local parameters = {}
            for i, arg in ipairs({...}) do
                if i == 1 then
                    path = tostring(arg)
                else
                    if type(arg) == 'string' then
                        if arg:len() > 2 and arg:sub(1,1) == console.literal then
                            arg = arg:sub(2)
                        else
                            local node, id, parent, found = console.node_from_path(console.fill_path(arg))
                            if node ~= nil and found then
                                arg = node
                            end
                        end
                    end
                    table.insert(parameters, arg)
                end
            end
            if path == nil then
                return console.error_bb .. '<you must supply a function>[-]'
            end
            local location = console.fill_path(path)
            local node, id, parent, found, location = console.node_from_path(location)
            local text = nil
            if node ~= nil and found and type(node) == 'function' then
                console.returned_value = node(unpack(parameters))
                text = tostring(console.returned_value)
                if console.deferred_assignment then
                    local da = console.deferred_assignment
                    if da.command == 'set' then
                        if da.parent[da.id] ~= nil then
                            if da.force or type(console.returned_value) == type(da.parent[da.id]) then
                                da.parent[da.id] = console.returned_value
                                text = text .. '\n' .. console.header_bb .. "<set '" .. da.id .. "'>[-]"
                            else
                                text = text .. '\n' .. console.error_bb .. "<cannot set '" .. da.id .. "': it is of type '" .. type(da.parent[da.id]) .. "'>[-]"
                            end
                        else
                            text = text .. '\n' .. console.error_bb .. "<cannot set '" .. da.id .. "': it does not exist>[-]"
                        end
                    elseif da.command == 'add' then
                        if da.parent[da.id] == nil then
                            da.parent[da.id] = console.returned_value
                            text = text .. '\n' .. console.header_bb .. "<added '" .. da.id .. "'>[-]"
                        else
                            text = text .. '\n' .. "<cannot add '" .. da.id .. "': it already exists>[-]"
                        end
                    end
                    console.deferred_assignment = nil
                end
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text, false
        end
    )

    console.add_admin_command('set', '['..console.option..'f] <variable> [<value>]',
        "Set variable to value.  If no value specified then the next value returned from 'call' is used.\n" ..
            console.option ..'f  force overwrite ignoring type',
        function (player, ...)
            local variable = nil
            local value = nil
            local force = false
            for _, arg in ipairs({...}) do
                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1, 1) == console.option then
                    local c = 2
                    while c <= arg:len() do
                        local option = arg:sub(c, c)
                        if option == "f" then
                            force = not force
                        else
                            return console.error_bb .. "<option '" .. option .. "' not recognized>[-]"
                        end
                        c = c + 1
                    end
                elseif variable == nil then
                    variable = tostring(arg)
                else
                    value = arg
                end
            end
            if variable == nil then
                return console.error_bb .. '<you must supply a variable>[-]'
            end
            variable = console.fill_path(variable)
            local node, id, parent, found = console.node_from_path(variable)
            local text = ''
            if node ~= nil and found then
                if value == nil then
                    console.deferred_assignment = {command = 'set', parent = parent, id = id, force = force}
                    text = id .. ': ' .. console.header_bb .. "<awaiting 'call'>[-]"
                else
                    console.deferred_assignment = nil
                    if type(value) == 'string' and value:len() > 0  then
                        if value:sub(1, 1) == console.literal then
                            value = value:sub(2)
                        else
                            local value_node, value_id, value_parent, value_found = console.node_from_path(value)
                            if value_node ~= nil and value_found then
                                value = value_node
                            else
                                return console.error_bb .. '<not found>[-]'
                            end
                        end
                    end
                    if type(node) == 'boolean' then
                        if not value or tostring(value):lower() == 'false' then
                            value = false
                        else
                            value = true
                        end
                    end
                    if type(node) == type(value) or force then
                        parent[id] = value
                        text = id .. ': ' .. console.value_bb .. tostring(parent[id]) .. '[-]'
                    else
                        return console.error_bb .. "<cannot set '" .. id .. "': it is of type '" .. type(node) .. "'>[-]"
                    end
                end
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text
        end
    )

    console.add_admin_command('toggle', '<boolean>',
        'Toggle specified boolean variable',
        function (player, variable)
            if variable == nil then
                return console.error_bb .. '<you must supply variable>'
            else
                variable = tostring(variable)
            end
            local variable = console.fill_path(variable)
            local node, id, parent, found = console.node_from_path(variable)
            local text = ''
            if node ~= nil and found then
                if type(node) == 'boolean' then
                    if node then
                        parent[id] = false
                        text = id .. ': ' .. console.value_bb .. 'false[-]'
                    else
                        parent[id] = true
                        text = id .. ': ' .. console.value_bb .. 'true[-]'
                    end
                else
                    text = console.error_bb .. '<can only toggle a boolean>[-]'
                end
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text
        end
    )
    console.add_admin_command('tgl', nil, nil, 'toggle')

    console.add_admin_command('rm', '<variable>',
        'Remove specified variable',
        function (player, variable)
            if variable == nil then
                return console.error_bb .. '<you must supply variable>'
            else
                variable = tostring(variable)
            end
            local variable = console.fill_path(variable)
            local node, id, parent, found = console.node_from_path(variable)
            local text = ''
            if node ~= nil and found then
                parent[id] = nil
                text = id .. " removed!"
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text
        end
    )
    console.add_admin_command('del', nil, nil, 'rm')

    console.add_admin_command('add', '<variable> [<value>]',
        "Create a variable set to value.   If no value specified then the next value returned from 'call' is used.",
        function (player, variable, value)
            if variable == nil then
                return console.error_bb .. '<you must supply variable>[-]'
            else
                variable = tostring(variable)
            end
            local variable = console.fill_path(variable)
            local node, id, parent, found = console.node_from_path(variable)
            local text = ''
            if found then
                return console.error_bb .. '<already exists>[-]'
            elseif node == nil or id == '' then
                return console.error_bb .. '<not found>[-]'
            else
                if value == nil then
                    console.deferred_assignment = {command = 'add', parent = node, id = id}
                    text = id .. ': ' .. console.header_bb .. "<awaiting 'call'>[-]"
                else
                    console.deferred_assignment = nil
                    if type(value) == 'string' and value:len() > 0  then
                        if value:sub(1, 1) == console.literal then
                            value = value:sub(2)
                        else
                            local value_node, value_id, value_parent, value_found = console.node_from_path(value)
                            if value_node ~= nil and value_found then
                                value = value_node
                            else
                                return console.error_bb .. '<not found>[-]'
                            end
                        end
                    end
                    node[id] = value
                    text = id .. ': ' .. console.value_bb .. tostring(value) .. '[-]'
                end
            end
            return text
        end
    )

    console.add_admin_command('exec', '['..console.option..'?qsv] <commands>',
        'Execute a series of commands held in a string: commands are seperated by a new line or '..console.command_seperator,
        function (player, ...)
            local help_details = console.option..'q    quiet: will not output anything except final output\n' ..
                                 console.option..'s    silent: will not output anything at all\n'..
                                 console.option..'v    verbose: will output commands as they execute\n'
            local commands = nil
            local verbose = false
            local quiet = false
            local silent = false
            for _, arg in ipairs({...}) do
                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1,1) == console.option then
                    local c = 2
                    while c <= arg:len() do
                        local option = arg:sub(c,c)
                        if option == '?' then
                            return help_details
                        elseif option == 'q' then
                            quiet = not quiet
                        elseif option == 's' then
                            silent = not silent
                        elseif option == 'v' then
                            verbose = not verbose
                        else
                            return console.error_bb .. "<option '" .. option .. "' not recognized>"
                        end
                        c = c + 1
                    end
                elseif commands == nil then
                    commands = tostring(arg)
                end
            end
            if silent then quiet = true end
            if commands:len() > 1 and commands:sub(1, 1) == console.literal then
                commands = commands:sub(2)
            else
                local variable = console.fill_path(commands)
                local node, id, parent, found = console.node_from_path(variable)
                if node ~= nil and found then
                    commands = node
                else
                    return console.error_bb .. '<not found>[-]'
                end
            end
            if commands:find('\n') then
                commands = console.split(commands, '\n')
            else
                commands = console.split(commands, console.command_seperator)
            end
            local end_result = nil
            for _, command_text in ipairs(commands) do
                local command = ''
                local command_function = nil
                local parameters = {player}
                local requires_admin = false
                command, command_function, parameters, requires_admin = console.get_command(command_text, player)
                if command ~= '' then
                    if command_function and (player.admin or not requires_admin) then
                        local response, mute = command_function(unpack(parameters))
                        if response ~= nil or mute ~= nil then
                            if not mute and verbose and not quiet then
                                printToColor('\n'..command_text, player.color, console.command_color)
                            end
                            if response then
                                end_result = response
                                if not quiet then
                                    printToColor(response, player.color, console.output_color)
                                end
                            end
                        end
                    elseif not quiet then
                        if verbose then printToColor('\n'..command_text, player.color, console.command_color) end
                        printToColor(console.error_bb .. "<command '" .. command .. "' not found>[-]", player.color, console.output_color)
                    end
                end
            end
            if end_result and not silent then
                printToColor(end_result, player.color, console.output_color)
            end
        end
    )

    console.add_admin_command('watch', '['..console.option..'?cgp] ['..console.option..'t#] ['..console.option..console.seperator..'<property>] [<variable>]',
        'Watch a variable or object and display it whenever it changes.\n' .. console.hidden_bb ..
        'Requires you to add a '..console.function_bb..'console.update()[-] call to an ' ..
        console.function_bb .. 'onUpdate[-] event in your code.[-]\n',
        function (player, ...)
            local help_details = 'Call without a parameter to display watched items, or with a variable to add it to watch list.\n' ..
                                console.option..'c will clear variable if specified, or all.\n' ..
                                console.option..'g will let you specify an object by its GUID.\n' ..
                                console.option..'t# will throttle output to # seconds.\n' ..
                                console.option..console.seperator..'<property> will watch the property of the variable.\n' ..
                                console.option..'p will pause or unpause watching.\n'
            local path = nil
            local clearing = false
            local throttle = nil
            local pause_changed = false
            local by_guid = false
            local parameters = {}
            local labels = {}
            local property = nil
            for _, arg in ipairs({...}) do
                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1,1) == console.option then
                    local c = 2
                    while c <= arg:len() do
                        local option = arg:sub(c,c)
                        if option == '?' then
                            return help_details
                        elseif option == 'c' then
                            clearing = not clearing
                        elseif option == 'p' then
                            pause_changed = not pause_changed
                        elseif option == 'g' then
                            by_guid = not by_guid
                        elseif option == console.seperator then
                            if arg:len() > c then
                                property = arg:sub(c + 1)
                                c = arg:len() + 1
                            end
                        elseif option == 't' then
                            local n = ''
                            local j = c + 1
                            while j <= arg:len() do
                                local char = arg:sub(j, j)
                                if char:match('[0-9.]') then
                                    n = n .. char
                                else
                                    break
                                end
                                j = j + 1
                            end
                            c = j - 1
                            if n == '' then
                                return console.error_bb .. '<you must provide a throttle duration (in seconds)>[-]'
                            else
                                throttle = tonumber(n)
                            end
                        else
                            return console.error_bb .. "<option '" .. option .. "' not recognized>"
                        end
                        c = c + 1
                    end
                else
                    if path == nil then
                        path = tostring(arg)
                    else
                        local label = tostring(arg)
                        if type(arg) == 'string' then
                            if arg:len() > 2 and arg:sub(1,1) == console.literal then
                                arg = arg:sub(2)
                                label = arg
                            else
                                local node, id, parent, found = console.node_from_path(console.fill_path(arg))
                                if node ~= nil and found then
                                    arg = node
                                end
                            end
                        end
                        table.insert(labels, label)
                        table.insert(parameters, arg)
                    end
                end
            end
            local text = ''
            if pause_changed then
                if console.watch_list_paused then
                    console.watch_list_paused = nil
                    text = text .. console.header_bb .. '<unpaused>[-]'
                else
                    console.watch_list_paused = true
                    text = text .. console.header_bb .. '<paused>[-]'
                end
            end
            if path == nil then
                if throttle ~= nil then
                    text = text .. '\n' .. console.error_bb .. '<you must provide a variable or object>[-]'
                elseif by_guid then
                    text = text .. '\n' .. console.error_bb .. '<you must provide a GUID>[-]'
                elseif clearing then
                    console.watch_list = nil
                    console.watch_list_paused = nil
                    text = text .. '\nWatch list cleared!'
                elseif not pause_changed then
                    if console.watch_list then
                        local watched = {}
                        for label, watch in pairs(console.watch_list) do
                            if watch.player == player.color then
                                table.insert(watched, label)
                            end
                        end
                        table.sort(watched)
                        text = text .. '\n'..console.header_bb..'Watching:[-]'
                        for _, label in ipairs(watched) do
                            local watch = console.watch_list[label]
                            local is_guid = (label:len() == 6 and label:sub(1,1) ~= console.seperator)
                            local node, id, parent, found
                            local prefix
                            text = text .. '\n'
                            if is_guid then
                                prefix =  console.format_guid(label)
                                node = getObjectFromGUID(label)
                                found = tostring(node) ~= 'null'
                            else
                                prefix = label
                                node, id, parent, found = console.node_from_path(label)
                            end
                            if node ~= nil and found then
                                if type(node) == 'userdata' then
                                    prefix = console.object_bb .. prefix .. '[-]'
                                    local position = node.getPosition()
                                    local rotation = node.getRotation()
                                    local p = function (x) return math.floor(x * 100) * 0.01 end
                                    local r = function (x) return math.floor(x + 0.5) end
                                    text = text .. prefix .. console.value_bb .. ' ∡ '..r(rotation.x)..' '..r(rotation.y)..' '..r(rotation.z) .. '[-]'..
                                            console.boolean_bb..'   ⊞  '..p(position.x)..'   '..p(position.y)..'   '..p(position.z)
                                elseif type(node) == 'function' then
                                    local result = node(unpack(console.watch_list[label].parameters))
                                    if watch.property and (type(result) == 'table' or type(result) == 'userdata') then
                                        result = result[watch.property]
                                        if type(result) == 'function' then
                                            result = result()
                                        end
                                    end
                                    result = tostring(result)
                                    if watch.propery and watch.property:lower():find('guid') then
                                        result = console.format_guid(result)
                                    end
                                    if result:len() > console.crop_string_at then result = result:sub(1, console.crop_string_at) .. '...' end
                                    text = text .. watch.label .. console.value_bb .. result .. '[-]'
                                else
                                    if type(node) == 'boolean' then
                                        if node then
                                            node = 'true'
                                        else
                                            node = 'false'
                                        end
                                    elseif type(node) == 'string' then
                                        if node:len() > console.crop_string_at then node = node:sub(1, console.crop_string_at):gsub('\n', ' ') .. '...' end
                                    end
                                    text = text .. prefix .. ': ' .. console.value_bb .. node .. '[-]'
                                end
                            end
                        end
                    else
                        text = text .. "\nWatch list is empty."
                    end
                end
            else
                if not by_guid then
                    path = console.fill_path(path)
                end
                if clearing then
                    local node, id, parent, found
                    if not by_guid then
                        node, id, parent, found, path = console.node_from_path(path)
                    end
                    if console.watch_list[path] then
                        console.watch_list[path] = nil
                        if next(console.watch_list) == nil then
                            console.watch_list = nil
                        end
                        text = text .. '\n' .. console.header_bb.. 'No longer watching:[-] ' .. path
                    else
                        text = text .. '\n' .. console.error_bb .. '<not found>[-]'
                    end
                else
                    local node, id, parent, found
                    if by_guid then
                        node = getObjectFromGUID(path)
                        found = tostring(node) ~= 'null'
                    else
                        node, id, parent, found, path = console.node_from_path(path)
                    end
                    if node ~= nil and found then
                        if console.watch_list == nil then console.watch_list = {} end
                        if throttle == nil then throttle = 0 end
                        console.watch_list[path] = {player=player.color, throttle=throttle, last_check=0, property=property}
                        if type(node) == 'userdata' then
                            console.watch_list[path].position = node.getPosition()
                            console.watch_list[path].rotation = node.getRotation()
                            console.watch_list[path].is_guid  = by_guid
                        elseif type(node) == 'function' then
                            console.watch_list[path].parameters = parameters
                            console.watch_list[path].value = node
                            console.watch_list[path].label = console.function_bb .. path .. '[-]'
                            if property then
                                console.watch_list[path].label = console.watch_list[path].label .. console.seperator .. property
                            end
                            for _, label in ipairs(labels) do
                                console.watch_list[path].label = console.watch_list[path].label .. ' ' .. console.hidden_bb .. label .. '[-]'
                            end
                            console.watch_list[path].label = console.watch_list[path].label .. ': '
                        else
                            console.watch_list[path].value = node
                        end
                        if by_guid then
                            path = console.format_guid(path)
                        end
                        text = text .. '\n' .. console.header_bb .. 'Watching:[-] ' .. path
                    else
                        text = text .. '\n' .. console.error_bb .. '<not found>[-]'
                    end
                end
            end
            if text:len() > 1 and text:sub(1, 1) == '\n' then
                text = text:sub(2)
            end
            return text
        end
    )

    console.add_player_command('shout', '<text>',
        'Broadcast <text> to all players. Colour a section with {RRGGBB}section{-}.',
        function (player, ...)
            local text = player.steam_name .. ': '
            local space = ''
            for _, word in ipairs({...}) do
                text = text .. space .. tostring(word)
                space = ' '
            end
            text = text:gsub('{','[')
            text = text:gsub('}',']')
            broadcastToAll(text, stringColorToRGB(player.color))
            return nil, false
        end
    )

    -- change the command help color so client added commands appear different to console++
    console.set_command_listing_bb('[A0F0C0]')
end

end)
__bundle_register("Console/console", function(require, _LOADED, __bundle_register, __bundle_modules)
if not console then
    console = {}

    -- Change these values as you wish
    console.command_char = '>'
    console.option       = '-'
    console.prompt_color  = {r = 0.8,  g = 1.0,  b = 0.8 }
    console.command_color = {r = 0.8,  g = 0.6,  b = 0.8 }
    console.output_color  = {r = 0.88, g = 0.88, b = 0.88}
    console.invalid_color = {r = 1.0,  g = 0.2,  b = 0.2 }
    console.header_bb       = '[EECCAA]'
    console.error_bb        = '[FF9999]'
    console.inbuilt_help_bb = '[E0E0E0]'
    console.client_help_bb  = '[C0C0FF]'

    -- Exposed methods:

    function console.add_validation_function(validation_function)
        -- Adds a validation function all chat will be checked against:
        -- function(string message) which returns (boolean valid, string response)
        -- If all validation functions return <valid> as true the message will be displayed.
        -- If one returns <valid> as false then its <response> will be displayed to that player instead.
        table.insert(console.validation_functions, validation_function)
    end

    function console.add_player_command(command, parameter_text, help_text, command_function, default_parameters)
        -- Adds a command anyone can use, see below for details
        console.add_command(command, false, parameter_text, help_text, command_function, default_parameters)
    end

    function console.add_admin_command(command, parameter_text, help_text, command_function, default_parameters)
        -- Adds a command only admins can use, see below for details
        console.add_command(command, true, parameter_text, help_text, command_function, default_parameters)
    end

    function console.add_command(command, requires_admin, parameter_text, help_text, command_function, default_parameters)
        -- Adds a command to the console.
        -- command_function must take <player> as its first argument, and then any
        --   subsequent arguments you wish which will be provided by the player.
        -- You may alias an already-present command by calling this with command_function set to
        --   the command string instead of a function.  default_parameters can be set for the alias.
        -- See basic built-in commands at the bottom of this file for examples.
        local commands = console.commands
        local command_function = command_function
        local help_text = help_text
        local parameter_text = parameter_text
        if type(command_function) == 'string' then --alias
            if help_text == nil then
                help_text = commands[command_function].help_text
            end
            if parameter_text == nil then
                parameter_text = commands[command_function].parameter_text
            end
            command_function = commands[command_function].command_function
        end
        console.commands[command] = {
            command_function   = command_function,
            requires_admin     = requires_admin,
            parameter_text     = parameter_text,
            help_text          = help_text,
            help_bb            = console.command_help_bb,
            default_parameters = default_parameters,
        }
    end

    function console.set_command_listing_bb(bb)
        -- Tags commands added after with a bb color for when they are displayed (i.e. with 'help')
        console.command_help_bb = bb
    end

    function console.disable()
        -- Disables console for command purposes, but leaves validation functions running
        console.active = false
    end

    function console.enable()
        -- Enables console commands (console commands are on by default)
        console.active = true
    end

    -- End of exposed methods.  You shouldn't need to interact with anything below (under normal circumstances)


    console.active = true
    console.in_command_mode = {}
    console.commands = {}
    console.validation_functions = {}
    console.set_command_listing_bb(console.inbuilt_help_bb)

    function onChat(message, player)
        if message ~= '' then
            local command = ''
            local command_function = nil
            local parameters = {player}
            local requires_admin = false
            local command_mode = console.in_command_mode[player.steam_id]
            if command_mode and console.active then
                command, command_function, parameters, requires_admin = console.get_command(message, player)
            elseif message:sub(1, 1) == console.command_char and console.active then
                if message:len() > 1 then
                    command, command_function, parameters, requires_admin = console.get_command(message:sub(2), player)
                else
                    command, command_function, parameters, requires_admin = console.get_command(console.command_char, player)
                end
            else
                for i, f in ipairs(console.validation_functions) do
                    local valid, response = f(message)
                    if response == nil then response = '' end
                    if not valid then
                        printToColor(response, player.color, console.invalid_color)
                        return false
                    end
                end
                return true
            end
            if console.active then
                if command_function and (player.admin or not requires_admin) then
                    if command_mode then
                        message = console.command_char .. console.command_char .. message
                    end
                    local response, mute = command_function(unpack(parameters))
                    if response ~= nil or mute ~= nil then
                        if not mute then
                            printToColor('\n'..message, player.color, console.command_color)
                        end
                        if response then
                            printToColor(response, player.color, console.output_color)
                        end
                    end
                    if console.in_command_mode[player.steam_id] then console.display_prompt(player) end
                    return false
                else
                    printToColor('\n'..message, player.color, console.command_color)
                    printToColor(console.error_bb .. "<command '" .. command .. "' not found>[-]", player.color, console.output_color)
                    return false
                end
            end
        end
    end

    function console.get_command(message, player)
        local command_name = ''
        local command_function = nil
        local requires_admin = false
        local parameters = {player}
        for i, part in ipairs(console.split(message)) do
            if i == 1 then
                command_name = part
                local command = console.commands[command_name]
                if command then
                    command_function = command.command_function
                    requires_admin = command.requires_admin
                    if command.default_parameters then
                        for _, parameter in ipairs(command.default_parameters) do
                            table.insert(parameters, parameter)
                        end
                    end
                end
            else
                table.insert(parameters, part)
            end
        end
        return command_name, command_function, parameters, requires_admin
    end

    function console.display_prompt(player)
        printToColor(console.command_char..console.command_char, player.color, console.prompt_color)
    end

    function console.split(text, split_on)
        local split_on = split_on or ' '
        if type(split_on) == 'string' then
            local s = {}
            for c = 1, split_on:len() do
                s[split_on:sub(c,c)] = true
            end
            split_on = s
        end
        local parts = {}
        if text ~= '' then
            local make_table = function(s)
                local entries = console.split(s, ' ,')
                local t = {}
                for _, entry in ipairs(entries) do
                    if type(entry) == 'string' and entry:find('=') then
                        e = console.split(entry, '=')
                        t[e[1]] = e[2]
                    else
                        table.insert(t, entry)
                    end
                end
                return t
            end
            local current_split_on = split_on
            local adding = false
            local part = ""
            local totype = tonumber
            for c = 1, text:len() do
                local char = text:sub(c, c)
                if adding then
                    if current_split_on[char] then -- ended current part
                        if totype(part) ~= nil then
                            table.insert(parts, totype(part))
                        else
                            table.insert(parts, part)
                        end
                        adding = false
                        current_split_on = split_on
                        totype = tonumber
                    else
                        part = part .. char
                    end
                else
                    if not current_split_on[char] then -- found start of part
                        if char == "'" then
                            current_split_on = {["'"] = true}
                            totype = tostring
                            part = ''
                        elseif char == '"' then
                            current_split_on = {['"'] = true}
                            totype = tostring
                            part = ''
                        elseif char == '{' then
                            current_split_on = {['}'] = true}
                            totype = make_table
                            part = ''
                        else
                            part = char
                        end
                        adding = true
                    end
                end
            end
            if adding then
                if totype(part) ~= nil then
                    table.insert(parts, totype(part))
                else
                    table.insert(parts, part)
                end
            end
        end
        return parts
    end


    -- Add basic built-in console commands

    console.add_player_command('help', '[' .. console.option .. 'all|<command>]',
        'Display available commands or help on all commands or help on a specific command.',
        function (player, command)
            if command ~= nil then
                command = tostring(command)
            end
            local make_help = function (command)
                return console.header_bb .. command .. ' ' .. console.commands[command].parameter_text ..
                        '[-]\n' .. console.commands[command].help_text
            end
            local info_mode = false
            if command == console.option..'all' then
                info_mode = true
            end
            if command and console.commands[command] then
                return make_help(command)
            elseif command and not info_mode then
                return console.error_bb .. "<command '" .. command .. "' not found>[-]"
            else
                local msg = console.header_bb .. 'Available commands:[-]'
                local command_list = {}
                for c, _ in pairs(console.commands) do
                    if player.admin or not console.commands[c].requires_admin then
                        if info_mode then
                            table.insert(command_list, make_help(c))
                        else
                            table.insert(command_list, c)
                        end
                    end
                end
                table.sort(command_list)
                local sep
                if info_mode then
                    sep = '\n\n'
                else
                    sep = '\n'
                end
                for _, c in ipairs(command_list) do
                    local cmd = console.commands[c]
                    if cmd then
                        msg = msg .. sep .. cmd.help_bb .. c .. '[-]'
                    else
                        msg = msg .. sep .. c
                    end
                    if not info_mode then sep = ', ' end
                end
                return msg
            end
        end
    )
    console.add_player_command('?', nil, nil, 'help')
    console.add_player_command('info', '', 'Display help on all available commands.', 'help', {console.option..'all'})

    console.add_player_command('exit', '',
        "Leave <command mode> ('" .. console.command_char .. "' does the same).",
        function (player)
            console.in_command_mode[player.steam_id] = nil
            return console.header_bb .. '<command mode: off>[-]'
        end
    )

    console.add_player_command('cmd', '',
        "Enter <command mode> ('" .. console.command_char .. "' does the same).",
        function (player)
            console.in_command_mode[player.steam_id] = true
            return console.header_bb .. '<command mode: on>[-]'
        end
    )

    console.add_player_command(console.command_char, '',
        'Toggle <command mode>',
        function (player)
            console.in_command_mode[player.steam_id] = not console.in_command_mode[player.steam_id]
            if console.in_command_mode[player.steam_id] then
                return console.header_bb .. '<command mode: on>[-]', true
            else
                return console.header_bb .. '<command mode: off>[-]', true
            end
        end
    )

    console.add_player_command('=', '<expression>',
        'Evaluate an expression',
        function (player, ...)
            local expression = ''
            for _, arg in ipairs({...}) do
                expression = expression .. ' ' .. tostring(arg)
            end
            if not player.admin then
                expression = expression:gasub('[a-zA-Z~]', '')
            end
            console.returned_value = dynamic.eval(expression)
            return console.returned_value
        end
    )

    console.add_player_command('echo', '<text>',
        'Display text on screen',
        function (player, ...)
            local text = ''
            for _, arg in ipairs({...}) do
                text = text .. ' ' .. tostring(arg)
            end
            printToColor(text, player.color, console.output_color)
            return false
        end
    )

    console.add_player_command('cls', '',
        'Clear console text',
        function (player)
            return '\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n' ..
                   '\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'
        end
    )

    console.add_player_command('alias', '<alias> <command> [<parameter>...]',
        'Create a command alias.',
        function (player, ...)
            local alias
            local command
            local parameters = {}
            for i, arg in ipairs({...}) do
                if i == 1 then
                    alias = tostring(arg)
                elseif i == 2 then
                    command = tostring(arg)
                else
                    table.insert(parameters, arg)
                end
            end
            if not alias then
                return console.error_bb .. '<must provide an alias>[-]'
            --elseif console.commands[alias] ~= nil then
            --    return console.error_bb .. "<command '" .. alias .. "' already exists!>[-]"
            elseif command == nil then
                return console.error_bb .. "<must provide a command>[-]"
            elseif console.commands[command] == nil then
                return console.error_bb .. "<command '" .. command .. "' does not exist>[-]"
            else
                local text = console.header_bb .. alias .. '[-] = ' .. command
                local help_text = console.commands[command].help_text
                if not help_text:find('\nAliased to: ') then
                    help_text = help_text .. '\nAliased to: ' .. command
                end
                local combined_parameters = {}
                if console.commands[command].default_parameters then
                    for _, parameter in ipairs(console.commands[command].default_parameters) do
                        table.insert(combined_parameters, parameter)
                    end
                end
                for _, parameter in ipairs(parameters) do
                    table.insert(combined_parameters, parameter)
                    text = text .. ' ' .. parameter
                    help_text = help_text .. ' ' .. parameter
                end
                console.add_command(alias, console.commands[command].requires_admin, console.commands[command].parameter_text, help_text, command, combined_parameters)
                return text
            end
        end
    )

    -- change the command help color so client added commands appear different to in-built
    console.set_command_listing_bb(console.client_help_bb)
end

end)
return __bundle_require("Yellow Machine.46ccee.lua")